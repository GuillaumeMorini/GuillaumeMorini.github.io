<!DOCTYPE html>
<html>
  <head>
    <title>ARAS85  Orchestration et containers </title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="workshop.css">
  </head>
  <body>
    <!--
    <div style="position: absolute; left: 20%; right: 20%; top: 30%;">
      <h1 style="font-size: 3em;">Loading ...</h1>
      The slides should show up here. If they don't, it might be
      because you are accessing this file directly from your filesystem.
      It needs to be served from a web server. You can try this:
      <pre>
        docker-compose up -d
        open http://localhost:8888/workshop.html # on MacOS
        xdg-open http://localhost:8888/workshop.html # on Linux
      </pre>
      Once the slides are loaded, this notice disappears when you
      go full screen (e.g. by hitting "f").
    </div>
    -->
    <textarea id="source">class: title, in-person

ARAS85 <br/>Orchestration et containers<br/><br /><br />

<div style="text-align: right"><a href="https://www.youtube.com/watch?v=h16zyxiwDLY"> Video </a></div>

[@GuillaumeMorini]: https://twitter.com/GuillaumeMorini

.footnote[
    Enseignant: [@GuillaumeMorini] <br/>
    Formation Ing√©nieur en apprentissage<br/>
    majeure ¬´ R√©seaux et S√©curit√© ¬ª<br/>
    2√®me ann√©e
    <!-- **Slides: https://container.training/** -->
]

<!--
WiFi: **Something**<br/>
Password: **Something**

**Be kind to the WiFi!**<br/>
*Use the 5G network.*
*Don't use your hotspot.*<br/>
*Don't stream videos or download big files during the workshop*<br/>
*Thank you!*
-->

.debug[
```
 M slides/efrei.yml
 M slides/k8s/concepts-k8s.md
 M slides/k8s/kubectlget.md
 M slides/k8s/setup-overview.md
 M slides/workshop.css
?? slides/containers/dockercoins.md
?? slides/efrei_day_1.yml
?? slides/efrei_day_2.yml
?? slides/efrei_day_3.yml
?? slides/efrei_day_4.yml
?? slides/images/congrats.gif
?? slides/images/floor_is_yours.jpg

```

These slides have been built from commit: 906b2b2


[shared/title.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/title.md)]
---
## Introductions

- Hello! I am Guillaume Morini ([@GuillaumeMorini])
   - I have worked at PSA Peugeot Citro√´n <img src="images/psa.jpeg" alt="PSA" width="64"/>, PMU üèá, Cisco <img src="images/cisco2.png" alt="Cisco" width="64"/>, Docker üê≥, VMware <img src="images/vmware.png" alt="VMware" width="32"/>and Google Cloud <img src="images/google_cloud.png" alt="Google Cloud" width="32"/>

- The training will run for 4 hours, with a 30 minutes break in the middle

- Feel free to interrupt for questions at any time. 
  - *Especially when you see full screen container pictures!*

- Use [Teams](https://teams.microsoft.com/l/team/19%3AhDyLe_wF4EzV8ZwhO0X9vj_j1Cg7baPkrFbvI4homEM1%40thread.tacv2/conversations?groupId=9388dd59-aeb3-474e-b7c7-620e860359de&tenantId=413600cf-bd4e-4c7c-8a61-69e73cddf731) to ask questions, get help, etc.


[@GuillaumeMorini]: https://twitter.com/GuillaumeMorini

.debug[[logistics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/logistics.md)]
---

## Exercises

- During the sessions, there are exercises

- To make the most out of the training, please try the exercises!

  (it will help to practice and memorize the content of the day)

- We recommend to take at least one hour to work on the exercises

  (if you understood the content of the day, it will be much faster)

- Each session will start with a quick review of the exercises of the previous session

.debug[[logistics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/logistics.md)]
---
## A brief introduction

- These materials reuse work done by [J√©r√¥me Petazzoni](https://twitter.com/jpetazzo) and [multiple contributors](https://https://github.com/GuillaumeMorini/orchestration-workshop/graphs/contributors)

- I have included as much information as possible in these slides

- ... but be comfortable spending some time reading the Docker
 [documentation](https://docs.docker.com/) ...

- ... And looking for answers in the [Docker forums](https://forums.docker.com),
  [StackOverflow](http://stackoverflow.com/questions/tagged/docker),
  and other outlets

.debug[[containers/intro.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/intro.md)]
---

class: self-paced

## Hands on, you shall practice

- Nobody ever became a Jedi by spending their lives reading Wookiepedia

- Likewise, it will take more than merely *reading* these slides
  to make you an expert

- These slides include *tons* of demos, exercises, and examples

- They assume that you have access to a machine running Docker

- If you are attending a workshop or tutorial:
  <br/>you will be given specific instructions to access a cloud VM

- If you are doing this on your own:
  <br/>we will tell you how to install Docker or access a Docker environment

.debug[[containers/intro.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/intro.md)]
---
## Chat room

- A Microsot Teams teams has been set up for the duration of the training

- We'll use it to ask questions, get help, share feedback ...

  (let's keep an eye on it during the training!)

- Reminder, the room is [Teams](https://teams.microsoft.com/l/team/19%3AhDyLe_wF4EzV8ZwhO0X9vj_j1Cg7baPkrFbvI4homEM1%40thread.tacv2/conversations?groupId=9388dd59-aeb3-474e-b7c7-620e860359de&tenantId=413600cf-bd4e-4c7c-8a61-69e73cddf731)

- Say hi in the chat room!


.debug[[shared/chat-room-teams.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/chat-room-teams.md)]
---

name: toc-part-1

## Part 1

- [Docker 30,000ft overview](#toc-docker-ft-overview)
- [History of containers ... and Docker](#toc-history-of-containers--and-docker)
- [Our training environment](#toc-our-training-environment)
- [Our first containers](#toc-our-first-containers)
- [Background containers](#toc-background-containers)
- [Understanding Docker images](#toc-understanding-docker-images)
- [Building images interactively](#toc-building-images-interactively)
- [Building Docker images with a Dockerfile](#toc-building-docker-images-with-a-dockerfile)
- [`CMD` and `ENTRYPOINT`](#toc-cmd-and-entrypoint)
- [Copying files during the build](#toc-copying-files-during-the-build)
- [Exercise ‚Äî writing Dockerfiles](#toc-exercise--writing-dockerfiles)

.debug[(auto-generated TOC)]
---
name: toc-part-2

## Part 2

- [Exercise ‚Äî writing Dockerfiles](#toc-exercise--writing-dockerfiles)
- [Naming and inspecting containers](#toc-naming-and-inspecting-containers)
- [Labels](#toc-labels)
- [Restarting and attaching to containers](#toc-restarting-and-attaching-to-containers)
- [Getting inside a container](#toc-getting-inside-a-container)
- [Limiting resources](#toc-limiting-resources)
- [Container networking basics](#toc-container-networking-basics)
- [Container network drivers](#toc-container-network-drivers)
- [The Container Network Model](#toc-the-container-network-model)
- [Service discovery with containers](#toc-service-discovery-with-containers)
- [Local development workflow with Docker](#toc-local-development-workflow-with-docker)
- [Working with volumes](#toc-working-with-volumes)
- [Gentle introduction to YAML](#toc-gentle-introduction-to-yaml)
- [Compose for development stacks](#toc-compose-for-development-stacks)
- [Exercise ‚Äî writing a Compose file](#toc-exercise--writing-a-compose-file)

.debug[(auto-generated TOC)]
---
name: toc-part-3

## Part 3

- [Exercise ‚Äî writing a Compose file](#toc-exercise--writing-a-compose-file)

- [TP : Deploying a sample application](#toc-tp--deploying-a-sample-application)


.debug[(auto-generated TOC)]
---
name: toc-part-4

## Part 4

- [Kubernetes concepts](#toc-kubernetes-concepts)

- [Declarative vs imperative](#toc-declarative-vs-imperative)

- [Setting up Kubernetes](#toc-setting-up-kubernetes)

- [First contact with `kubectl`](#toc-first-contact-with-kubectl)

- [Running our first containers on Kubernetes](#toc-running-our-first-containers-on-kubernetes)

- [Revisiting `kubectl logs`](#toc-revisiting-kubectl-logs)

- [Exposing containers](#toc-exposing-containers)


.debug[(auto-generated TOC)]



.debug[[shared/toc.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/toc.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-docker-ft-overview
class: title

 Docker 30,000ft overview

.nav[
[Previous part](#toc-)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-history-of-containers--and-docker)
]

.debug[(automatically generated title slide)]

---
# Docker 30,000ft overview

In this lesson, we will learn about:

* Why containers (non-technical elevator pitch)

* Why containers (technical elevator pitch)

* How Docker helps us to build, ship, and run

* The history of containers

We won't actually run Docker or containers in this chapter (yet!).

Don't worry, we will get to that fast enough!

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

## Elevator pitch

### (for your manager, your boss...)

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

## OK... Why the buzz around containers?

* The software industry has changed

* Before:
  * monolithic applications
  * long development cycles
  * single environment
  * slowly scaling up

* Now:
  * decoupled services
  * fast, iterative improvements
  * multiple environments
  * quickly scaling out

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

## Deployment becomes very complex

* Many different stacks:
  * languages
  * frameworks
  * databases

* Many different targets:
  * individual development environments
  * pre-production, QA, staging...
  * production: on prem, cloud, hybrid

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: pic

## The deployment problem

![problem](images/shipping-software-problem.png)

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: pic

## The matrix from hell

![matrix](images/shipping-matrix-from-hell.png)

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: pic

## The parallel with the shipping industry

![history](images/shipping-industry-problem.png)

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: pic

## Intermodal shipping containers

![shipping](images/shipping-industry-solution.png)

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: pic

## A new shipping ecosystem

![shipeco](images/shipping-indsutry-results.png)

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: pic

## A shipping container system for applications

![shipapp](images/shipping-software-solution.png)

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: pic

## Eliminate the matrix from hell

![elimatrix](images/shipping-matrix-solved.png)

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

## Results

* [Dev-to-prod reduced from 9 months to 15 minutes (ING)](
  https://gallant-turing-d0d520.netlify.com/docker-case-studies/CS_ING_01.25.2015_1.pdf)

* [Continuous integration job time reduced by more than 60% (BBC)](
  https://gallant-turing-d0d520.netlify.com/docker-case-studies/CS_BBCNews_01.25.2015_1.pdf)

* [Deploy 100 times a day instead of once a week (GILT)](
  https://gallant-turing-d0d520.netlify.com/docker-case-studies/CS_Gilt_Groupe_03.18.2015_0.pdf)

* [70% infrastructure consolidation (MetLife)](
  https://www.youtube.com/watch?v=Bwt3xigvlj0)

* etc.

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

## Elevator pitch

### (for your fellow devs and ops)

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

## Escape dependency hell

1. Write installation instructions into an `INSTALL.txt` file

2. Using this file, write an `install.sh` script that works *for you*

3. Turn this file into a `Dockerfile`, test it on your machine

4. If the Dockerfile builds on your machine, it will build *anywhere*

5. Rejoice as you escape dependency hell and "works on my machine"

Never again "worked in dev - ops problem now!"

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

## On-board developers and contributors rapidly

1. Write Dockerfiles for your application components

2. Use pre-made images from the Docker Hub (mysql, redis...)

3. Describe your stack with a Compose file

4. On-board somebody with two commands:

```bash
git clone ...
docker-compose up
```

With this, you can create development, integration, QA environments in minutes!

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Implement reliable CI easily

1. Build test environment with a Dockerfile or Compose file

2. For each test run, stage up a new container or stack

3. Each run is now in a clean environment

4. No pollution from previous tests

Way faster and cheaper than creating VMs each time!

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Use container images as build artefacts

1. Build your app from Dockerfiles

2. Store the resulting images in a registry

3. Keep them forever (or as long as necessary)

4. Test those images in QA, CI, integration...

5. Run the same images in production

6. Something goes wrong? Rollback to previous image

7. Investigating old regression? Old image has your back!

Images contain all the libraries, dependencies, etc. needed to run the app.

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Decouple "plumbing" from application logic

1. Write your code to connect to named services ("db", "api"...)

2. Use Compose to start your stack

3. Docker will setup per-container DNS resolver for those names

4. You can now scale, add load balancers, replication ... without changing your code

Note: this is not covered in this intro level workshop!

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## What did Docker bring to the table?

### Docker before/after

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Formats and APIs, before Docker

* No standardized exchange format.
  <br/>(No, a rootfs tarball is *not* a format!)

* Containers are hard to use for developers.
  <br/>(Where's the equivalent of `docker run debian`?)

* As a result, they are *hidden* from the end users.

* No re-usable components, APIs, tools.
  <br/>(At best: VM abstractions, e.g. libvirt.)

Analogy: 

* Shipping containers are not just steel boxes.
* They are steel boxes that are a standard size, with the same hooks and holes.

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Formats and APIs, after Docker

* Standardize the container format, because containers were not portable.

* Make containers easy to use for developers.

* Emphasis on re-usable components, APIs, ecosystem of standard tools.

* Improvement over ad-hoc, in-house, specific tools.

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Shipping, before Docker

* Ship packages: deb, rpm, gem, jar, homebrew...

* Dependency hell.

* "Works on my machine."

* Base deployment often done from scratch (debootstrap...) and unreliable.

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Shipping, after Docker

* Ship container images with all their dependencies.

* Images are bigger, but they are broken down into layers.

* Only ship layers that have changed.

* Save disk, network, memory usage.

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Example

Layers:

* CentOS
* JRE
* Tomcat
* Dependencies
* Application JAR
* Configuration

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Devs vs Ops, before Docker

* Drop a tarball (or a commit hash) with instructions.

* Dev environment very different from production.

* Ops don't always have a dev environment themselves ...

* ... and when they do, it can differ from the devs'.

* Ops have to sort out differences and make it work ...

* ... or bounce it back to devs.

* Shipping code causes frictions and delays.

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: extra-details

## Devs vs Ops, after Docker

* Drop a container image or a Compose file.

* Ops can always run that container image.

* Ops can always run that Compose file.

* Ops still have to adapt to prod environment,
  but at least they have a reference point.

* Ops have tools allowing to use the same image
  in dev and prod.

* Devs can be empowered to make releases themselves
  more easily.

.debug[[containers/Docker_Overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_Overview.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-history-of-containers--and-docker
class: title

 History of containers ... and Docker

.nav[
[Previous part](#toc-docker-ft-overview)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-our-training-environment)
]

.debug[(automatically generated title slide)]

---
# History of containers ... and Docker

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## First experimentations

* [IBM VM/370 (1972)](https://en.wikipedia.org/wiki/VM_%28operating_system%29)

* [Linux VServers (2001)](http://www.solucorp.qc.ca/changes.hc?projet=vserver)

* [Solaris Containers (2004)](https://en.wikipedia.org/wiki/Solaris_Containers)

* [FreeBSD jails (1999-2000)](https://www.freebsd.org/cgi/man.cgi?query=jail&sektion=8&manpath=FreeBSD+4.0-RELEASE)

Containers have been around for a *very long time* indeed.

(See [this excellent blog post by Serge Hallyn](https://s3hh.wordpress.com/2018/03/22/history-of-containers/) for more historic details.)

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

class: pic

## The VPS age (until 2007-2008)

![lightcont](images/containers-as-lightweight-vms.png)

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## Containers = cheaper than VMs

* Users: hosting providers.

* Highly specialized audience with strong ops culture.

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

class: pic

## The PAAS period (2008-2013)

![heroku 2007](images/heroku-first-homepage.png)

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## Containers = easier than VMs

* I can't speak for Heroku, but containers were (one of) dotCloud's secret weapon

* dotCloud was operating a PaaS, using a custom container engine.

* This engine was based on OpenVZ (and later, LXC) and AUFS.

* It started (circa 2008) as a single Python script.

* By 2012, the engine had multiple (~10) Python components.
  <br/>(and ~100 other micro-services!)

* End of 2012, dotCloud refactors this container engine.

* The codename for this project is "Docker."

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## First public release of Docker

* March 2013, PyCon, Santa Clara:
  <br/>"Docker" is shown to a public audience for the first time.

* It is released with an open source license.

* Very positive reactions and feedback!

* The dotCloud team progressively shifts to Docker development.

* The same year, dotCloud changes name to Docker.

* In 2014, the PaaS activity is sold.

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## Docker early days (2013-2014)

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## First users of Docker

* PAAS builders (Flynn, Dokku, Tsuru, Deis...)

* PAAS users (those big enough to justify building their own)

* CI platforms

* developers, developers, developers, developers

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## Positive feedback loop

* In 2013, the technology under containers (cgroups, namespaces, copy-on-write storage...)
  had many blind spots.

* The growing popularity of Docker and containers exposed many bugs.

* As a result, those bugs were fixed, resulting in better stability for containers.

* Any decent hosting/cloud provider can run containers today.

* Containers become a great tool to deploy/move workloads to/from on-prem/cloud.

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## Maturity (2015-2016)

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## Docker becomes an industry standard

* Docker reaches the symbolic 1.0 milestone.

* Existing systems like Mesos and Cloud Foundry add Docker support.

* Standardization around the OCI (Open Containers Initiative).

* Other container engines are developed.

* Creation of the CNCF (Cloud Native Computing Foundation).

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

## Docker becomes a platform

* The initial container engine is now known as "Docker Engine."

* Other tools are added:
  * Docker Compose (formerly "Fig")
  * Docker Machine
  * Docker Swarm
  * Kitematic
  * Docker Cloud (formerly "Tutum")
  * Docker Datacenter
  * etc.

* Docker Inc. launches commercial offers.

.debug[[containers/Docker_History.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Docker_History.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-our-training-environment
class: title

 Our training environment

.nav[
[Previous part](#toc-history-of-containers--and-docker)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-our-first-containers)
]

.debug[(automatically generated title slide)]

---

class: title

# Our training environment

![SSH terminal](images/title-our-training-environment.jpg)

.debug[[containers/Training_Environment.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Training_Environment.md)]
---

## Our training environment

- 2 VMs has been provisioned for three students

- They were created just before the training.

- They will stay up during the whole training.

- They will be destroyed shortly after the training.

- They do not come pre-loaded with Docker, so you need to install everything.

<img src="images/qrcode_docs.google.com.png" alt="VMs Sheets QR Code" width="200" align="right"/>

.debug[[containers/Training_Environment.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Training_Environment.md)]
---

## What *is* Docker?

- "Installing Docker" really means "Installing the Docker Engine and CLI".

- The Docker Engine is a daemon (a service running in the background).

- This daemon manages containers, the same way that a hypervisor manages VMs.

- We interact with the Docker Engine by using the Docker CLI.

- The Docker CLI and the Docker Engine communicate through an API.

- There are many other programs and client libraries which use that API.

.debug[[containers/Training_Environment.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Training_Environment.md)]
---

## Why don't we run Docker locally?

- We are going to download container images and distribution packages.

- This could put a bit of stress on the local WiFi and slow us down.

- Instead, we use remote VMs that has a good connectivity

- In some rare cases, installing Docker locally is challenging:

  - no administrator/root access (computer managed by strict corp IT)

  - 32-bit CPU or OS

  - old OS version (e.g. CentOS 6, OSX pre-Yosemite, Windows 7)

- It's better to spend time learning containers than fiddling with the installer!

.debug[[containers/Training_Environment.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Training_Environment.md)]
---

## Connecting to your Virtual Machine

You need an SSH client.

* On OS X, Linux, and other UNIX systems, just use `ssh`:

```bash
$ ssh <login>@<ip-address>
```

* On Windows, if you don't have an SSH client, you can download:

  * Putty (www.putty.org)

  * Git BASH (https://git-for-windows.github.io/)

  * MobaXterm (https://mobaxterm.mobatek.net/)

.debug[[containers/Training_Environment.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Training_Environment.md)]
---

## Checking your Virtual Machine

Once logged in, goal is to be able to run a basic Docker command:

.small[
```bash
$ docker version
Client:
 Version:       18.03.0-ce
 API version:   1.37
 Go version:    go1.9.4
 Git commit:    0520e24
 Built:         Wed Mar 21 23:10:06 2018
 OS/Arch:       linux/amd64
 Experimental:  false
 Orchestrator:  swarm

Server:
 Engine:
  Version:      18.03.0-ce
  API version:  1.37 (minimum version 1.12)
  Go version:   go1.9.4
  Git commit:   0520e24
  Built:        Wed Mar 21 23:08:35 2018
  OS/Arch:      linux/amd64
  Experimental: false
```
]

If this doesn't work, raise your hand so that an instructor can assist you!

???

:EN:Container concepts
:FR:Premier contact avec les conteneurs

:EN:- What's a container engine?
:FR:- Qu'est-ce qu'un *container engine* ?

.debug[[containers/Training_Environment.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Training_Environment.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/blue-containers.jpg)]

---

name: toc-our-first-containers
class: title

 Our first containers

.nav[
[Previous part](#toc-our-training-environment)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-background-containers)
]

.debug[(automatically generated title slide)]

---

class: title

# Our first containers

![Colorful plastic tubs](images/title-our-first-containers.jpg)

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Objectives

At the end of this lesson, you will have:

* Seen Docker in action.

* Started your first containers.

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Hello World

In your Docker environment, just run the following command:

```bash
$ docker run busybox echo hello world
hello world
```

(If your Docker install is brand new, you will also see a few extra lines,
corresponding to the download of the `busybox` image.)

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## That was our first container!

* We used one of the smallest, simplest images available: `busybox`.

* `busybox` is typically used in embedded systems (phones, routers...)

* We ran a single process and echo'ed `hello world`.

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## A more useful container

Let's run a more exciting container:

```bash
$ docker run -it ubuntu
root@04c0bb0a6c07:/#
```

* This is a brand new container.

* It runs a bare-bones, no-frills `ubuntu` system.

* `-it` is shorthand for `-i -t`.

  * `-i` tells Docker to connect us to the container's stdin.

  * `-t` tells Docker that we want a pseudo-terminal.

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Do something in our container

Try to run `figlet` in our container.

```bash
root@04c0bb0a6c07:/# figlet hello
bash: figlet: command not found
```

Alright, we need to install it.

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Install a package in our container

We want `figlet`, so let's install it:

```bash
root@04c0bb0a6c07:/# apt-get update
...
Fetched 1514 kB in 14s (103 kB/s)
Reading package lists... Done
root@04c0bb0a6c07:/# apt-get install figlet
Reading package lists... Done
...
```

One minute later, `figlet` is installed!

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Try to run our freshly installed program

The `figlet` program takes a message as parameter.

```bash
root@04c0bb0a6c07:/# figlet hello
 _          _ _       
| |__   ___| | | ___  
| '_ \ / _ \ | |/ _ \ 
| | | |  __/ | | (_) |
|_| |_|\___|_|_|\___/ 
```

Beautiful! üòç

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

class: in-person

## Counting packages in the container

Let's check how many packages are installed there.

```bash
root@04c0bb0a6c07:/# dpkg -l | wc -l
97
```

* `dpkg -l` lists the packages installed in our container

* `wc -l` counts them

How many packages do we have on our host?

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

class: in-person

## Counting packages on the host

Exit the container by logging out of the shell, like you would usually do.

(E.g. with `^D` or `exit`)

```bash
root@04c0bb0a6c07:/# exit
```

Now, try to:

* run `dpkg -l | wc -l`. How many packages are installed?

* run `figlet`. Does that work?

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

class: self-paced

## Comparing the container and the host

Exit the container by logging out of the shell, with `^D` or `exit`.

Now try to run `figlet`. Does that work?

(It shouldn't; except if, by coincidence, you are running on a machine where figlet was installed before.)

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Host and containers are independent things

* We ran an `ubuntu` container on an Linux/Windows/macOS host.

* They have different, independent packages.

* Installing something on the host doesn't expose it to the container.

* And vice-versa.

* Even if both the host and the container have the same Linux distro!

* We can run *any container* on *any host*.

  (One exception: Windows containers can only run on Windows hosts; at least for now.)

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Where's our container?

* Our container is now in a *stopped* state.

* It still exists on disk, but all compute resources have been freed up.

* We will see later how to get back to that container.

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Starting another container

What if we start a new container, and try to run `figlet` again?
 
```bash
$ docker run -it ubuntu
root@b13c164401fb:/# figlet
bash: figlet: command not found
```

* We started a *brand new container*.

* The basic Ubuntu image was used, and `figlet` is not here.

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Where's my container?

* Can we reuse that container that we took time to customize?

  *We can, but that's not the default workflow with Docker.*

* What's the default workflow, then?

  *Always start with a fresh container.*
  <br/>
  *If we need something installed in our container, build a custom image.*

* That seems complicated!

  *We'll see that it's actually pretty easy!*

* And what's the point?

  *This puts a strong emphasis on automation and repeatability. Let's see why ...*

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Pets vs. Cattle

* In the "pets vs. cattle" metaphor, there are two kinds of servers.

* Pets:

  * have distinctive names and unique configurations

  * when they have an outage, we do everything we can to fix them

* Cattle:

  * have generic names (e.g. with numbers) and generic configuration

  * configuration is enforced by configuration management, golden images ...

  * when they have an outage, we can replace them immediately with a new server

* What's the connection with Docker and containers?

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Local development environments

* When we use local VMs (with e.g. VirtualBox or VMware), our workflow looks like this:

  * create VM from base template (Ubuntu, CentOS...)

  * install packages, set up environment

  * work on project

  * when done, shut down VM

  * next time we need to work on project, restart VM as we left it

  * if we need to tweak the environment, we do it live

* Over time, the VM configuration evolves, diverges.

* We don't have a clean, reliable, deterministic way to provision that environment.

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

## Local development with Docker

* With Docker, the workflow looks like this:

  * create container image with our dev environment

  * run container with that image

  * work on project

  * when done, shut down container

  * next time we need to work on project, start a new container

  * if we need to tweak the environment, we create a new image

* We have a clear definition of our environment, and can share it reliably with others.

* Let's see in the next chapters how to bake a custom image with `figlet`!

???

:EN:- Running our first container
:FR:- Lancer nos premiers conteneurs

.debug[[containers/First_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/First_Containers.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/chinook-helicopter-container.jpg)]

---

name: toc-background-containers
class: title

 Background containers

.nav[
[Previous part](#toc-our-first-containers)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-understanding-docker-images)
]

.debug[(automatically generated title slide)]

---

class: title

# Background containers

![Background containers](images/title-background-containers.jpg)

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## Objectives

Our first containers were *interactive*.

We will now see how to:

* Run a non-interactive container.
* Run a container in the background.
* List running containers.
* Check the logs of a container.
* Stop a container.
* List stopped containers.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## A non-interactive container

We will run a small custom container.

This container just displays the time every second.

```bash
$ docker run jpetazzo/clock
Fri Feb 20 00:28:53 UTC 2015
Fri Feb 20 00:28:54 UTC 2015
Fri Feb 20 00:28:55 UTC 2015
...
```

* This container will run forever.
* To stop it, press `^C`.
* Docker has automatically downloaded the image `jpetazzo/clock`.
* This image is a user image, created by `jpetazzo`.
* We will hear more about user images (and other types of images) later.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## When `^C` doesn't work...

Sometimes, `^C` won't be enough.

Why? And how can we stop the container in that case?

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## What happens when we hit `^C`

`SIGINT` gets sent to the container, which means:

- `SIGINT` gets sent to PID 1 (default case)

- `SIGINT` gets sent to *foreground processes* when running with `-ti`

But there is a special case for PID 1: it ignores all signals!

- except `SIGKILL` and `SIGSTOP`

- except signals handled explicitly

TL,DR: there are many circumstances when `^C` won't stop the container.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

class: extra-details

## Why is PID 1 special?

- PID 1 has some extra responsibilities:

  - it starts (directly or indirectly) every other process

  - when a process exits, its processes are "reparented" under PID 1

- When PID 1 exits, everything stops:

  - on a "regular" machine, it causes a kernel panic

  - in a container, it kills all the processes

- We don't want PID 1 to stop accidentally

- That's why it has these extra protections

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## How to stop these containers, then?

- Start another terminal and forget about them

  (for now!)

- We'll shortly learn about `docker kill`

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## Run a container in the background

Containers can be started in the background, with the `-d` flag (daemon mode):

```bash
$ docker run -d jpetazzo/clock
47d677dcfba4277c6cc68fcaa51f932b544cab1a187c853b7d0caf4e8debe5ad
```

* We don't see the output of the container.
* But don't worry: Docker collects that output and logs it!
* Docker gives us the ID of the container.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## List running containers

How can we check that our container is still running?

With `docker ps`, just like the UNIX `ps` command, lists running processes.

```bash
$ docker ps
CONTAINER ID  IMAGE           ...  CREATED        STATUS        ...
47d677dcfba4  jpetazzo/clock  ...  2 minutes ago  Up 2 minutes  ...
```

Docker tells us:

* The (truncated) ID of our container.
* The image used to start the container.
* That our container has been running (`Up`) for a couple of minutes.
* Other information (COMMAND, PORTS, NAMES) that we will explain later.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## Starting more containers

Let's start two more containers.

```bash
$ docker run -d jpetazzo/clock
57ad9bdfc06bb4407c47220cf59ce21585dce9a1298d7a67488359aeaea8ae2a
```

```bash
$ docker run -d jpetazzo/clock
068cc994ffd0190bbe025ba74e4c0771a5d8f14734af772ddee8dc1aaf20567d
```

Check that `docker ps` correctly reports all 3 containers.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## Viewing only the last container started

When many containers are already running, it can be useful to
see only the last container that was started.

This can be achieved with the `-l` ("Last") flag:

```bash
$ docker ps -l
CONTAINER ID  IMAGE           ...  CREATED        STATUS        ...
068cc994ffd0  jpetazzo/clock  ...  2 minutes ago  Up 2 minutes  ...
```

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## View only the IDs of the containers

Many Docker commands will work on container IDs: `docker stop`, `docker rm`...

If we want to list only the IDs of our containers (without the other columns
or the header line),
we can use the `-q` ("Quiet", "Quick") flag:

```bash
$ docker ps -q
068cc994ffd0
57ad9bdfc06b
47d677dcfba4
```

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## Combining flags

We can combine `-l` and `-q` to see only the ID of the last container started:

```bash
$ docker ps -lq
068cc994ffd0
```

At a first glance, it looks like this would be particularly useful in scripts.

However, if we want to start a container and get its ID in a reliable way,
it is better to use `docker run -d`, which we will cover in a bit.

(Using `docker ps -lq` is prone to race conditions: what happens if someone
else, or another program or script, starts another container just before
we run `docker ps -lq`?)

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## View the logs of a container

We told you that Docker was logging the container output.

Let's see that now.

```bash
$ docker logs 068
Fri Feb 20 00:39:52 UTC 2015
Fri Feb 20 00:39:53 UTC 2015
...
```

* We specified a *prefix* of the full container ID.
* You can, of course, specify the full ID.
* The `logs` command will output the *entire* logs of the container.
  <br/>(Sometimes, that will be too much. Let's see how to address that.)

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## View only the tail of the logs

To avoid being spammed with eleventy pages of output,
we can use the `--tail` option:

```bash
$ docker logs --tail 3 068
Fri Feb 20 00:55:35 UTC 2015
Fri Feb 20 00:55:36 UTC 2015
Fri Feb 20 00:55:37 UTC 2015
```

* The parameter is the number of lines that we want to see.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## Follow the logs in real time

Just like with the standard UNIX command `tail -f`, we can
follow the logs of our container:

```bash
$ docker logs --tail 1 --follow 068
Fri Feb 20 00:57:12 UTC 2015
Fri Feb 20 00:57:13 UTC 2015
^C
```

* This will display the last line in the log file.
* Then, it will continue to display the logs in real time.
* Use `^C` to exit.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## Stop our container

There are two ways we can terminate our detached container.

* Killing it using the `docker kill` command.
* Stopping it using the `docker stop` command.

The first one stops the container immediately, by using the
`KILL` signal.

The second one is more graceful. It sends a `TERM` signal,
and after 10 seconds, if the container has not stopped, it
sends `KILL.`

Reminder: the `KILL` signal cannot be intercepted, and will
forcibly terminate the container.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## Stopping our containers

Let's stop one of those containers:

```bash
$ docker stop 47d6
47d6
```

This will take 10 seconds:

* Docker sends the TERM signal;
* the container doesn't react to this signal
  (it's a simple Shell script with no special
  signal handling);
* 10 seconds later, since the container is still
  running, Docker sends the KILL signal;
* this terminates the container.

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## Killing the remaining containers

Let's be less patient with the two other containers:

```bash
$ docker kill 068 57ad
068
57ad
```

The `stop` and `kill` commands can take multiple container IDs.

Those containers will be terminated immediately (without
the 10-second delay).

Let's check that our containers don't show up anymore:

```bash
$ docker ps
```

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

## List stopped containers

We can also see stopped containers, with the `-a` (`--all`) option.

```bash
$ docker ps -a
CONTAINER ID  IMAGE           ...  CREATED      STATUS
068cc994ffd0  jpetazzo/clock  ...  21 min. ago  Exited (137) 3 min. ago
57ad9bdfc06b  jpetazzo/clock  ...  21 min. ago  Exited (137) 3 min. ago
47d677dcfba4  jpetazzo/clock  ...  23 min. ago  Exited (137) 3 min. ago
5c1dfd4d81f1  jpetazzo/clock  ...  40 min. ago  Exited (0) 40 min. ago
b13c164401fb  ubuntu          ...  55 min. ago  Exited (130) 53 min. ago
```

???

:EN:- Foreground and background containers
:FR:- Ex√©cution interactive ou en arri√®re-plan

.debug[[containers/Background_Containers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Background_Containers.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-cranes.jpg)]

---

name: toc-understanding-docker-images
class: title

 Understanding Docker images

.nav[
[Previous part](#toc-background-containers)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-building-images-interactively)
]

.debug[(automatically generated title slide)]

---

class: title

# Understanding Docker images

![image](images/title-understanding-docker-images.png)

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Objectives

In this section, we will explain:

* What is an image.

* What is a layer.

* The various image namespaces.

* How to search and download images.

* Image tags and when to use them.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## What is an image?

* Image = files + metadata

* These files form the root filesystem of our container.

* The metadata can indicate a number of things, e.g.:

  * the author of the image
  * the command to execute in the container when starting it
  * environment variables to be set
  * etc.

* Images are made of *layers*, conceptually stacked on top of each other.

* Each layer can add, change, and remove files and/or metadata.

* Images can share layers to optimize disk usage, transfer times, and memory use.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Example for a Java webapp

Each of the following items will correspond to one layer:

* CentOS base layer
* Packages and configuration files added by our local IT
* JRE
* Tomcat
* Our application's dependencies
* Our application code and assets
* Our application configuration

(Note: app config is generally added by orchestration facilities.)

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

class: pic

## The read-write layer

![layers](images/container-layers.jpg)

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Differences between containers and images

* An image is a read-only filesystem.

* A container is an encapsulated set of processes,

  running in a read-write copy of that filesystem.

* To optimize container boot time, *copy-on-write* is used
  instead of regular copy.

* `docker run` starts a container from a given image.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

class: pic

## Multiple containers sharing the same image

![layers](images/sharing-layers.jpg)

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Comparison with object-oriented programming

* Images are conceptually similar to *classes*.

* Layers are conceptually similar to *inheritance*.

* Containers are conceptually similar to *instances*.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Wait a minute...

If an image is read-only, how do we change it?

* We don't.

* We create a new container from that image.

* Then we make changes to that container.

* When we are satisfied with those changes, we transform them into a new layer.

* A new image is created by stacking the new layer on top of the old image.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## A chicken-and-egg problem

* The only way to create an image is by "freezing" a container.

* The only way to create a container is by instantiating an image.

* Help!

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Creating the first images

There is a special empty image called `scratch`.

* It allows to *build from scratch*.

The `docker import` command loads a tarball into Docker.

* The imported tarball becomes a standalone image.
* That new image has a single layer.

Note: you will probably never have to do this yourself.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Creating other images

`docker commit`

* Saves all the changes made to a container into a new layer.
* Creates a new image (effectively a copy of the container).

`docker build` **(used 99% of the time)**

* Performs a repeatable build sequence.
* This is the preferred method!

We will explain both methods in a moment.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Images namespaces

There are three namespaces:

* Official images

    e.g. `ubuntu`, `busybox` ...

* User (and organizations) images

    e.g. `jpetazzo/clock`

* Self-hosted images

    e.g. `registry.example.com:5000/my-private/image`

Let's explain each of them.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Root namespace

The root namespace is for official images.

They are gated by Docker Inc.

They are generally authored and maintained by third parties.

Those images include:

* Small, "swiss-army-knife" images like busybox.

* Distro images to be used as bases for your builds, like ubuntu, fedora...

* Ready-to-use components and services, like redis, postgresql...

* Over 150 at this point!

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## User namespace

The user namespace holds images for Docker Hub users and organizations.

For example:

```bash
jpetazzo/clock
```

The Docker Hub user is:

```bash
jpetazzo
```

The image name is:

```bash
clock
```

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Self-hosted namespace

This namespace holds images which are not hosted on Docker Hub, but on third
party registries.

They contain the hostname (or IP address), and optionally the port, of the
registry server.

For example:

```bash
localhost:5000/wordpress
```

* `localhost:5000` is the host and port of the registry
* `wordpress` is the name of the image

Other examples:

```bash
quay.io/coreos/etcd
gcr.io/google-containers/hugo
```

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## How do you store and manage images?

Images can be stored:

* On your Docker host.
* In a Docker registry.

You can use the Docker client to download (pull) or upload (push) images.

To be more accurate: you can use the Docker client to tell a Docker Engine
to push and pull images to and from a registry.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Showing current images

Let's look at what images are on our host now.

```bash
$ docker images
REPOSITORY       TAG       IMAGE ID       CREATED         SIZE
fedora           latest    ddd5c9c1d0f2   3 days ago      204.7 MB
centos           latest    d0e7f81ca65c   3 days ago      196.6 MB
ubuntu           latest    07c86167cdc4   4 days ago      188 MB
redis            latest    4f5f397d4b7c   5 days ago      177.6 MB
postgres         latest    afe2b5e1859b   5 days ago      264.5 MB
alpine           latest    70c557e50ed6   5 days ago      4.798 MB
debian           latest    f50f9524513f   6 days ago      125.1 MB
busybox          latest    3240943c9ea3   2 weeks ago     1.114 MB
training/namer   latest    902673acc741   9 months ago    289.3 MB
jpetazzo/clock   latest    12068b93616f   12 months ago   2.433 MB
```

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Searching for images

We cannot list *all* images on a remote registry, but
we can search for a specific keyword:

```bash
$ docker search marathon
NAME                     DESCRIPTION                     STARS  OFFICIAL  AUTOMATED
mesosphere/marathon      A cluster-wide init and co...   105              [OK]
mesoscloud/marathon      Marathon                        31               [OK]
mesosphere/marathon-lb   Script to update haproxy b...   22               [OK]
tobilg/mongodb-marathon  A Docker image to start a ...   4                [OK]
```


* "Stars" indicate the popularity of the image.

* "Official" images are those in the root namespace.

* "Automated" images are built automatically by the Docker Hub.
  <br/>(This means that their build recipe is always available.)

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Downloading images

There are two ways to download images.

* Explicitly, with `docker pull`.

* Implicitly, when executing `docker run` and the image is not found locally.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Pulling an image

```bash
$ docker pull debian:jessie
Pulling repository debian
b164861940b8: Download complete
b164861940b8: Pulling image (jessie) from debian
d1881793a057: Download complete
```

* As seen previously, images are made up of layers.

* Docker has downloaded all the necessary layers.

* In this example, `:jessie` indicates which exact version of Debian
  we would like.

  It is a *version tag*.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Image and tags

* Images can have tags.

* Tags define image versions or variants.

* `docker pull ubuntu` will refer to `ubuntu:latest`.

* The `:latest` tag is generally updated often.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## When to (not) use tags

Don't specify tags:

* When doing rapid testing and prototyping.
* When experimenting.
* When you want the latest version.

Do specify tags:

* When recording a procedure into a script.
* When going to production.
* To ensure that the same version will be used everywhere.
* To ensure repeatability later.

This is similar to what we would do with `pip install`, `npm install`, etc.

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

class: extra-details

## Multi-arch images

- An image can support multiple architectures

- More precisely, a specific *tag* in a given *repository* can have either:

  - a single *manifest* referencing an image for a single architecture

  - a *manifest list* (or *fat manifest*) referencing multiple images

- In a *manifest list*, each image is identified by a combination of:

  - `os` (linux, windows)

  - `architecture` (amd64, arm, arm64...)

  - optional fields like `variant` (for arm and arm64), `os.version` (for windows)

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

class: extra-details

## Working with multi-arch images

- The Docker Engine will pull "native" images when available

  (images matching its own os/architecture/variant)

- We can ask for a specific image platform with `--platform`

- The Docker Engine can run non-native images thanks to QEMU+binfmt

  (automatically on Docker Desktop; with a bit of setup on Linux)

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

## Section summary

We've learned how to:

* Understand images and layers.
* Understand Docker image namespacing.
* Search and download images.

???

:EN:Building images
:EN:- Containers, images, and layers
:EN:- Image addresses and tags
:EN:- Finding and transferring images

:FR:Construire des images
:FR:- La diff√©rence entre un conteneur et une image
:FR:- La notion de *layer* partag√© entre images

.debug[[containers/Initial_Images.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Initial_Images.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-housing.jpg)]

---

name: toc-building-images-interactively
class: title

 Building images interactively

.nav[
[Previous part](#toc-understanding-docker-images)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-building-docker-images-with-a-dockerfile)
]

.debug[(automatically generated title slide)]

---
# Building images interactively

In this section, we will create our first container image.

It will be a basic distribution image, but we will pre-install
the package `figlet`.

We will: 

* Create a container from a base image.

* Install software manually in the container, and turn it
  into a new image.

* Learn about new commands: `docker commit`, `docker tag`, and `docker diff`.

.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

## The plan

1. Create a container (with `docker run`) using our base distro of choice.

2. Run a bunch of commands to install and set up our software in the container.

3. (Optionally) review changes in the container with `docker diff`.

4. Turn the container into a new image with `docker commit`.

5. (Optionally) add tags to the image with `docker tag`.

.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

## Setting up our container

Start an Ubuntu container:

```bash
$ docker run -it ubuntu
root@<yourContainerId>:#/
```

Run the command `apt-get update` to refresh the list of packages available to install.

Then run the command `apt-get install figlet` to install the program we are interested in.

```bash
root@<yourContainerId>:#/ apt-get update && apt-get install figlet
.... OUTPUT OF APT-GET COMMANDS ....
```

.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

## Inspect the changes

Type `exit` at the container prompt to leave the interactive session.

Now let's run `docker diff` to see the difference between the base image
and our container.

```bash
$ docker diff <yourContainerId>
C /root
A /root/.bash_history
C /tmp
C /usr
C /usr/bin
A /usr/bin/figlet
...
```

.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

class: x-extra-details

## Docker tracks filesystem changes

As explained before:

* An image is read-only.

* When we make changes, they happen in a copy of the image.

* Docker can show the difference between the image, and its copy.

* For performance, Docker uses copy-on-write systems.
  <br/>(i.e. starting a container based on a big image
  doesn't incur a huge copy.)

.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

## Copy-on-write security benefits

* `docker diff` gives us an easy way to audit changes

  (√† la Tripwire)

* Containers can also be started in read-only mode

  (their root filesystem will be read-only, but they can still have read-write data volumes)


.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

## Commit our changes into a new image

The `docker commit` command will create a new layer with those changes,
and a new image using this new layer.

```bash
$ docker commit <yourContainerId>
<newImageId>
```

The output of the `docker commit` command will be the ID for your newly created image.

We can use it as an argument to `docker run`.

.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

## Testing our new image

Let's run this image:

```bash
$ docker run -it <newImageId>
root@fcfb62f0bfde:/# figlet hello
 _          _ _       
| |__   ___| | | ___  
| '_ \ / _ \ | |/ _ \ 
| | | |  __/ | | (_) |
|_| |_|\___|_|_|\___/ 
```

It works! üéâ

.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

## Tagging images

Referring to an image by its ID is not convenient. Let's tag it instead.

We can use the `tag` command:

```bash
$ docker tag <newImageId> figlet
```

But we can also specify the tag as an extra argument to `commit`:

```bash
$ docker commit <containerId> figlet
```

And then run it using its tag:

```bash
$ docker run -it figlet
```

.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

## What's next?

Manual process = bad.

Automated process = good.

In the next chapter, we will learn how to automate the build
process by writing a `Dockerfile`.

???

:EN:- Building our first images interactively
:FR:- Fabriquer nos premi√®res images √† la main

.debug[[containers/Building_Images_Interactively.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_Interactively.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/containers-by-the-water.jpg)]

---

name: toc-building-docker-images-with-a-dockerfile
class: title

 Building Docker images with a Dockerfile

.nav[
[Previous part](#toc-building-images-interactively)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-cmd-and-entrypoint)
]

.debug[(automatically generated title slide)]

---

class: title

# Building Docker images with a Dockerfile

![Construction site with containers](images/title-building-docker-images-with-a-dockerfile.jpg)

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Objectives

We will build a container image automatically, with a `Dockerfile`.

At the end of this lesson, you will be able to:

* Write a `Dockerfile`.

* Build an image from a `Dockerfile`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## `Dockerfile` overview

* A `Dockerfile` is a build recipe for a Docker image.

* It contains a series of instructions telling Docker how an image is constructed.

* The `docker build` command builds an image from a `Dockerfile`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Writing our first `Dockerfile`

Our Dockerfile must be in a **new, empty directory**.

1. Create a directory to hold our `Dockerfile`.

```bash
$ mkdir myimage
```

2. Create a `Dockerfile` inside this directory.

```bash
$ cd myimage
$ vim Dockerfile
```

Of course, you can use any other editor of your choice.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Type this into our Dockerfile...

```dockerfile
FROM ubuntu
RUN apt-get update
RUN apt-get install figlet
```

* `FROM` indicates the base image for our build.

* Each `RUN` line will be executed by Docker during the build.

* Our `RUN` commands **must be non-interactive.**
  <br/>(No input can be provided to Docker during the build.)

* In many cases, we will add the `-y` flag to `apt-get`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Build it!

Save our file, then execute:

```bash
$ docker build -t figlet .
```

* `-t` indicates the tag to apply to the image.

* `.` indicates the location of the *build context*.

We will talk more about the build context later.

To keep things simple for now: this is the directory where our Dockerfile is located.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## What happens when we build the image?

It depends if we're using BuildKit or not!

If there are lots of blue lines and the first line looks like this:
```
[+] Building 1.8s (4/6)
```
... then we're using BuildKit.

If the output is mostly black-and-white and the first line looks like this:
```
Sending build context to Docker daemon  2.048kB
```
... then we're using the "classic" or "old-style" builder.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## To BuildKit or Not To BuildKit

Classic builder:

- copies the whole "build context" to the Docker Engine

- linear (processes lines one after the other)

- requires a full Docker Engine

BuildKit:

- only transfers parts of the "build context" when needed

- will parallelize operations (when possible)

- can run in non-privileged containers (e.g. on Kubernetes)

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## With the classic builder

The output of `docker build` looks like this:

.small[
```bash
docker build -t figlet .
Sending build context to Docker daemon  2.048kB
Step 1/3 : FROM ubuntu
 ---> f975c5035748
Step 2/3 : RUN apt-get update
 ---> Running in e01b294dbffd
(...output of the RUN command...)
Removing intermediate container e01b294dbffd
 ---> eb8d9b561b37
Step 3/3 : RUN apt-get install figlet
 ---> Running in c29230d70f9b
(...output of the RUN command...)
Removing intermediate container c29230d70f9b
 ---> 0dfd7a253f21
Successfully built 0dfd7a253f21
Successfully tagged figlet:latest
```
]

* The output of the `RUN` commands has been omitted.
* Let's explain what this output means.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Sending the build context to Docker

```bash
Sending build context to Docker daemon 2.048 kB
```

* The build context is the `.` directory given to `docker build`.

* It is sent (as an archive) by the Docker client to the Docker daemon.

* This allows to use a remote machine to build using local files.

* Be careful (or patient) if that directory is big and your link is slow.

* You can speed up the process with a [`.dockerignore`](https://docs.docker.com/engine/reference/builder/#dockerignore-file) file

  * It tells docker to ignore specific files in the directory

  * Only ignore files that you won't need in the build context!

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Executing each step

```bash
Step 2/3 : RUN apt-get update
 ---> Running in e01b294dbffd
(...output of the RUN command...)
Removing intermediate container e01b294dbffd
 ---> eb8d9b561b37
```

* A container (`e01b294dbffd`) is created from the base image.

* The `RUN` command is executed in this container.

* The container is committed into an image (`eb8d9b561b37`).

* The build container (`e01b294dbffd`) is removed.

* The output of this step will be the base image for the next one.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## With BuildKit

.small[
```bash
[+] Building 7.9s (7/7) FINISHED
 => [internal] load build definition from Dockerfile                                                 0.0s
 => => transferring dockerfile: 98B                                                                  0.0s
 => [internal] load .dockerignore                                                                    0.0s
 => => transferring context: 2B                                                                      0.0s
 => [internal] load metadata for docker.io/library/ubuntu:latest                                     1.2s
 => [1/3] FROM docker.io/library/ubuntu@sha256:cf31af331f38d1d7158470e095b132acd126a7180a54f263d386  3.2s
 => => resolve docker.io/library/ubuntu@sha256:cf31af331f38d1d7158470e095b132acd126a7180a54f263d386  0.0s
 => => sha256:cf31af331f38d1d7158470e095b132acd126a7180a54f263d386da88eb681d93 1.20kB / 1.20kB       0.0s
 => => sha256:1de4c5e2d8954bf5fa9855f8b4c9d3c3b97d1d380efe19f60f3e4107a66f5cae 943B / 943B           0.0s
 => => sha256:6a98cbe39225dadebcaa04e21dbe5900ad604739b07a9fa351dd10a6ebad4c1b 3.31kB / 3.31kB       0.0s
 => => sha256:80bc30679ac1fd798f3241208c14accd6a364cb8a6224d1127dfb1577d10554f 27.14MB / 27.14MB     2.3s
 => => sha256:9bf18fab4cfbf479fa9f8409ad47e2702c63241304c2cdd4c33f2a1633c5f85e 850B / 850B           0.5s
 => => sha256:5979309c983a2adeff352538937475cf961d49c34194fa2aab142effe19ed9c1 189B / 189B           0.4s
 => => extracting sha256:80bc30679ac1fd798f3241208c14accd6a364cb8a6224d1127dfb1577d10554f            0.7s
 => => extracting sha256:9bf18fab4cfbf479fa9f8409ad47e2702c63241304c2cdd4c33f2a1633c5f85e            0.0s
 => => extracting sha256:5979309c983a2adeff352538937475cf961d49c34194fa2aab142effe19ed9c1            0.0s
 => [2/3] RUN apt-get update                                                                         2.5s
 => [3/3] RUN apt-get install figlet                                                                 0.9s
 => exporting to image                                                                               0.1s
 => => exporting layers                                                                              0.1s
 => => writing image sha256:3b8aee7b444ab775975dfba691a72d8ac24af2756e0a024e056e3858d5a23f7c         0.0s
 => => naming to docker.io/library/figlet                                                            0.0s
 ```
 ]

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Understanding BuildKit output

- BuildKit transfers the Dockerfile and the *build context*

  (these are the first two `[internal]` stages)

- Then it executes the steps defined in the Dockerfile

  (`[1/3]`, `[2/3]`, `[3/3]`)

- Finally, it exports the result of the build

  (image definition + collection of layers)

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

class: extra-details

## BuildKit plain output

- When running BuildKit in e.g. a CI pipeline, its output will be different

- We can see the same output format by using `--progress=plain`

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## The caching system

If you run the same build again, it will be instantaneous. Why?

* After each build step, Docker takes a snapshot of the resulting image.

* Before executing a step, Docker checks if it has already built the same sequence.

* Docker uses the exact strings defined in your Dockerfile, so:

  * `RUN apt-get install figlet cowsay`
    <br/> is different from
    <br/> `RUN apt-get install cowsay figlet`

  * `RUN apt-get update` is not re-executed when the mirrors are updated

You can force a rebuild with `docker build --no-cache ...`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Running the image

The resulting image is not different from the one produced manually.

```bash
$ docker run -ti figlet
root@91f3c974c9a1:/# figlet hello
 _          _ _       
| |__   ___| | | ___  
| '_ \ / _ \ | |/ _ \ 
| | | |  __/ | | (_) |
|_| |_|\___|_|_|\___/ 
```


Yay! üéâ

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Using image and viewing history

The `history` command lists all the layers composing an image.

For each layer, it shows its creation time, size, and creation command.

When an image was built with a Dockerfile, each layer corresponds to
a line of the Dockerfile.

```bash
$ docker history figlet
IMAGE         CREATED            CREATED BY                     SIZE
f9e8f1642759  About an hour ago  /bin/sh -c apt-get install fi  1.627 MB
7257c37726a1  About an hour ago  /bin/sh -c apt-get update      21.58 MB
07c86167cdc4  4 days ago         /bin/sh -c #(nop) CMD ["/bin   0 B
<missing>     4 days ago         /bin/sh -c sed -i 's/^#\s*\(   1.895 kB
<missing>     4 days ago         /bin/sh -c echo '#!/bin/sh'    194.5 kB
<missing>     4 days ago         /bin/sh -c #(nop) ADD file:b   187.8 MB
```

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

class: extra-details

## Why `sh -c`?

* On UNIX, to start a new program, we need two system calls:

  - `fork()`, to create a new child process;

  - `execve()`, to replace the new child process with the program to run.

* Conceptually, `execve()` works like this:

  `execve(program, [list, of, arguments])`

* When we run a command, e.g. `ls -l /tmp`, something needs to parse the command.

  (i.e. split the program and its arguments into a list.)

* The shell is usually doing that.

  (It also takes care of expanding environment variables and special things like `~`.)

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

class: extra-details

## Why `sh -c`?

* When we do `RUN ls -l /tmp`, the Docker builder needs to parse the command.

* Instead of implementing its own parser, it outsources the job to the shell.

* That's why we see `sh -c ls -l /tmp` in that case.

* But we can also do the parsing jobs ourselves.

* This means passing `RUN` a list of arguments.

* This is called the *exec syntax*.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Shell syntax vs exec syntax

Dockerfile commands that execute something can have two forms:

* plain string, or *shell syntax*:
  <br/>`RUN apt-get install figlet`

* JSON list, or *exec syntax*:
  <br/>`RUN ["apt-get", "install", "figlet"]`

We are going to change our Dockerfile to see how it affects the resulting image.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Using exec syntax in our Dockerfile

Let's change our Dockerfile as follows!

```dockerfile
FROM ubuntu
RUN apt-get update
RUN ["apt-get", "install", "figlet"]
```

Then build the new Dockerfile.

```bash
$ docker build -t figlet .
```

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## History with exec syntax

Compare the new history:

```bash
$ docker history figlet
IMAGE         CREATED            CREATED BY                     SIZE
27954bb5faaf  10 seconds ago     apt-get install figlet         1.627 MB
7257c37726a1  About an hour ago  /bin/sh -c apt-get update      21.58 MB
07c86167cdc4  4 days ago         /bin/sh -c #(nop) CMD ["/bin   0 B
<missing>     4 days ago         /bin/sh -c sed -i 's/^#\s*\(   1.895 kB
<missing>     4 days ago         /bin/sh -c echo '#!/bin/sh'    194.5 kB
<missing>     4 days ago         /bin/sh -c #(nop) ADD file:b   187.8 MB
```

* Exec syntax specifies an *exact* command to execute.

* Shell syntax specifies a command to be wrapped within `/bin/sh -c "..."`.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## When to use exec syntax and shell syntax

* shell syntax:

  * is easier to write
  * interpolates environment variables and other shell expressions
  * creates an extra process (`/bin/sh -c ...`) to parse the string
  * requires `/bin/sh` to exist in the container

* exec syntax:

  * is harder to write (and read!)
  * passes all arguments without extra processing
  * doesn't create an extra process
  * doesn't require `/bin/sh` to exist in the container

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Pro-tip: the `exec` shell built-in

POSIX shells have a built-in command named `exec`.

`exec` should be followed by a program and its arguments.

From a user perspective:

- it looks like the shell exits right away after the command execution,

- in fact, the shell exits just *before* command execution;

- or rather, the shell gets *replaced* by the command.

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

## Example using `exec`

```dockerfile
CMD exec figlet -f script hello
```

In this example, `sh -c` will still be used, but
`figlet` will be PID 1 in the container.

The shell gets replaced by `figlet` when `figlet` starts execution.

This allows to run processes as PID 1 without using JSON.

???

:EN:- Towards automated, reproducible builds
:EN:- Writing our first Dockerfile
:FR:- Rendre le processus automatique et reproductible
:FR:- √âcrire son premier Dockerfile

.debug[[containers/Building_Images_With_Dockerfiles.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Building_Images_With_Dockerfiles.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/distillery-containers.jpg)]

---

name: toc-cmd-and-entrypoint
class: title

 `CMD` and `ENTRYPOINT`

.nav[
[Previous part](#toc-building-docker-images-with-a-dockerfile)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-copying-files-during-the-build)
]

.debug[(automatically generated title slide)]

---

class: title

# `CMD` and `ENTRYPOINT`

![Container entry doors](images/entrypoint.jpg)

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Objectives

In this lesson, we will learn about two important
Dockerfile commands:

`CMD` and `ENTRYPOINT`.

These commands allow us to set the default command
to run in a container.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Defining a default command

When people run our container, we want to greet them with a nice hello message, and using a custom font.

For that, we will execute:

```bash
figlet -f script hello
```

* `-f script` tells figlet to use a fancy font.

* `hello` is the message that we want it to display.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Adding `CMD` to our Dockerfile

Our new Dockerfile will look like this:

```dockerfile
FROM ubuntu
RUN apt-get update
RUN ["apt-get", "install", "figlet"]
CMD figlet -f script hello
```

* `CMD` defines a default command to run when none is given.

* It can appear at any point in the file.

* Each `CMD` will replace and override the previous one.

* As a result, while you can have multiple `CMD` lines, it is useless.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Build and test our image

Let's build it:

```bash
$ docker build -t figlet .
...
Successfully built 042dff3b4a8d
Successfully tagged figlet:latest
```

And run it:

```bash
$ docker run figlet
 _          _   _       
| |        | | | |      
| |     _  | | | |  __  
|/ \   |/  |/  |/  /  \_
|   |_/|__/|__/|__/\__/ 
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Overriding `CMD`

If we want to get a shell into our container (instead of running
`figlet`), we just have to specify a different program to run:

```bash
$ docker run -it figlet bash
root@7ac86a641116:/# 
```

* We specified `bash`.

* It replaced the value of `CMD`.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Using `ENTRYPOINT`

We want to be able to specify a different message on the command line,
while retaining `figlet` and some default parameters.

In other words, we would like to be able to do this:

```bash
$ docker run figlet salut
           _            
          | |           
 ,   __,  | |       _|_ 
/ \_/  |  |/  |   |  |  
 \/ \_/|_/|__/ \_/|_/|_/
```


We will use the `ENTRYPOINT` verb in Dockerfile.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Adding `ENTRYPOINT` to our Dockerfile

Our new Dockerfile will look like this:

```dockerfile
FROM ubuntu
RUN apt-get update
RUN ["apt-get", "install", "figlet"]
ENTRYPOINT ["figlet", "-f", "script"]
```

* `ENTRYPOINT` defines a base command (and its parameters) for the container.

* The command line arguments are appended to those parameters.

* Like `CMD`, `ENTRYPOINT` can appear anywhere, and replaces the previous value.

Why did we use JSON syntax for our `ENTRYPOINT`?

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Implications of JSON vs string syntax

* When CMD or ENTRYPOINT use string syntax, they get wrapped in `sh -c`.

* To avoid this wrapping, we can use JSON syntax.

What if we used `ENTRYPOINT` with string syntax?

```bash
$ docker run figlet salut
```

This would run the following command in the `figlet` image:

```bash
sh -c "figlet -f script" salut
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Build and test our image

Let's build it:

```bash
$ docker build -t figlet .
...
Successfully built 36f588918d73
Successfully tagged figlet:latest
```

And run it:

```bash
$ docker run figlet salut
           _            
          | |           
 ,   __,  | |       _|_ 
/ \_/  |  |/  |   |  |  
 \/ \_/|_/|__/ \_/|_/|_/
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Using `CMD` and `ENTRYPOINT` together

What if we want to define a default message for our container?

Then we will use `ENTRYPOINT` and `CMD` together.

* `ENTRYPOINT` will define the base command for our container.

* `CMD` will define the default parameter(s) for this command.

* They *both* have to use JSON syntax.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## `CMD` and `ENTRYPOINT` together

Our new Dockerfile will look like this:

```dockerfile
FROM ubuntu
RUN apt-get update
RUN ["apt-get", "install", "figlet"]
ENTRYPOINT ["figlet", "-f", "script"]
CMD ["hello world"]
```

* `ENTRYPOINT` defines a base command (and its parameters) for the container.

* If we don't specify extra command-line arguments when starting the container,
  the value of `CMD` is appended.

* Otherwise, our extra command-line arguments are used instead of `CMD`.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Build and test our image

Let's build it:

```bash
$ docker build -t myfiglet .
...
Successfully built 6e0b6a048a07
Successfully tagged myfiglet:latest
```

Run it without parameters:

```bash
$ docker run myfiglet
 _          _   _                             _        
| |        | | | |                           | |    |  
| |     _  | | | |  __             __   ,_   | |  __|  
|/ \   |/  |/  |/  /  \_  |  |  |_/  \_/  |  |/  /  |  
|   |_/|__/|__/|__/\__/    \/ \/  \__/    |_/|__/\_/|_/
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Overriding the image default parameters

Now let's pass extra arguments to the image.

```bash
$ docker run myfiglet hola mundo
 _           _                                               
| |         | |                                      |       
| |     __  | |  __,     _  _  _           _  _    __|   __  
|/ \   /  \_|/  /  |    / |/ |/ |  |   |  / |/ |  /  |  /  \_
|   |_/\__/ |__/\_/|_/    |  |  |_/ \_/|_/  |  |_/\_/|_/\__/ 
```

We overrode `CMD` but still used `ENTRYPOINT`.

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## Overriding `ENTRYPOINT`

What if we want to run a shell in our container?

We cannot just do `docker run myfiglet bash` because
that would just tell figlet to display the word "bash."

We use the `--entrypoint` parameter:

```bash
$ docker run -it --entrypoint bash myfiglet
root@6027e44e2955:/# 
```

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## `CMD` and `ENTRYPOINT` recap

- `docker run myimage` executes `ENTRYPOINT` + `CMD`

- `docker run myimage args` executes `ENTRYPOINT` + `args` (overriding `CMD`)

- `docker run --entrypoint prog myimage` executes `prog` (overriding both)

.small[
| Command                         | `ENTRYPOINT`       | `CMD`   | Result
|---------------------------------|--------------------|---------|-------
| `docker run figlet`             | none               | none    | Use values from base image (`bash`)
| `docker run figlet hola`        | none               | none    | Error (executable `hola` not found)
| `docker run figlet`             | `figlet -f script` | none    | `figlet -f script`
| `docker run figlet hola`        | `figlet -f script` | none    | `figlet -f script hola`
| `docker run figlet`             | none    | `figlet -f script` | `figlet -f script`
| `docker run figlet hola`        | none    | `figlet -f script` | Error (executable `hola` not found)
| `docker run figlet`             | `figlet -f script` | `hello` | `figlet -f script hello`
| `docker run figlet hola`        | `figlet -f script` | `hello` | `figlet -f script hola`
]

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

## When to use `ENTRYPOINT` vs `CMD`

`ENTRYPOINT` is great for "containerized binaries".

Example: `docker run consul --help`

(Pretend that the `docker run` part isn't there!)

`CMD` is great for images with multiple binaries.

Example: `docker run busybox ifconfig`

(It makes sense to indicate *which* program we want to run!)

???

:EN:- CMD and ENTRYPOINT
:FR:- CMD et ENTRYPOINT

.debug[[containers/Cmd_And_Entrypoint.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Cmd_And_Entrypoint.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/lots-of-containers.jpg)]

---

name: toc-copying-files-during-the-build
class: title

 Copying files during the build

.nav[
[Previous part](#toc-cmd-and-entrypoint)
|
[Back to table of contents](#toc-part-1)
|
[Next part](#toc-exercise--writing-dockerfiles)
]

.debug[(automatically generated title slide)]

---

class: title

# Copying files during the build

![Monks copying books](images/title-copying-files-during-build.jpg)

.debug[[containers/Copying_Files_During_Build.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Copying_Files_During_Build.md)]
---

## Objectives

So far, we have installed things in our container images
by downloading packages.

We can also copy files from the *build context* to the
container that we are building.

Remember: the *build context* is the directory containing
the Dockerfile.

In this chapter, we will learn a new Dockerfile keyword: `COPY`.

.debug[[containers/Copying_Files_During_Build.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Copying_Files_During_Build.md)]
---

## Build some C code

We want to build a container that compiles a basic "Hello world" program in C.

Here is the program, `hello.c`:

```bash
int main () {
  puts("Hello, world!");
  return 0;
}
```

Let's create a new directory, and put this file in there.

Then we will write the Dockerfile.

.debug[[containers/Copying_Files_During_Build.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Copying_Files_During_Build.md)]
---

## The Dockerfile

On Debian and Ubuntu, the package `build-essential` will get us a compiler.

When installing it, don't forget to specify the `-y` flag, otherwise the build will fail (since the build cannot be interactive).

Then we will use `COPY` to place the source file into the container.

```bash
FROM ubuntu
RUN apt-get update
RUN apt-get install -y build-essential
COPY hello.c /
RUN make hello
CMD /hello
```

Create this Dockerfile.

.debug[[containers/Copying_Files_During_Build.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Copying_Files_During_Build.md)]
---

## Testing our C program

* Create `hello.c` and `Dockerfile` in the same directory.

* Run `docker build -t hello .` in this directory.

* Run `docker run hello`, you should see `Hello, world!`.

Success!

.debug[[containers/Copying_Files_During_Build.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Copying_Files_During_Build.md)]
---

## `COPY` and the build cache

* Run the build again.

* Now, modify `hello.c` and run the build again.

* Docker can cache steps involving `COPY`.

* Those steps will not be executed again if the files haven't been changed.

.debug[[containers/Copying_Files_During_Build.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Copying_Files_During_Build.md)]
---

## Details

* We can `COPY` whole directories recursively

* It is possible to do e.g. `COPY . .`

  (but it might require some extra precautions to avoid copying too much)
 
* In older Dockerfiles, you might see the `ADD` command; consider it deprecated

  (it is similar to `COPY` but can automatically extract archives)

* If we really wanted to compile C code in a container, we would:

  * place it in a different directory, with the `WORKDIR` instruction

  * even better, use the `gcc` official image

.debug[[containers/Copying_Files_During_Build.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Copying_Files_During_Build.md)]
---

class: extra-details

## `.dockerignore`

- We can create a file named `.dockerignore`

  (at the top-level of the build context)

- It can contain file names and globs to ignore

- They won't be sent to the builder

  (and won't end up in the resulting image)

- See the [documentation][dockerignore] for the little details

  (exceptions can be made with `!`, multiple directory levels with `**`...)

[dockerignore]: https://docs.docker.com/engine/reference/builder/#dockerignore-file

???

:EN:- Leveraging the build cache for faster builds
:FR:- Tirer parti du cache afin d'optimiser la vitesse de *build*

.debug[[containers/Copying_Files_During_Build.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Copying_Files_During_Build.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/plastic-containers.JPG)]

---

name: toc-exercise--writing-dockerfiles
class: title

 Exercise ‚Äî writing Dockerfiles

.nav[
[Previous part](#toc-copying-files-during-the-build)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-exercise--writing-dockerfiles)
]

.debug[(automatically generated title slide)]

---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-1.jpg)]

---

name: toc-exercise--writing-dockerfiles
class: title

 Exercise ‚Äî writing Dockerfiles

.nav[
[Previous part](#toc-copying-files-during-the-build)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-exercise--writing-dockerfiles)
]

.debug[(automatically generated title slide)]

---
# Exercise ‚Äî writing Dockerfiles

Let's write Dockerfiles for an existing application!

1. Check out the code repository

2. Read all the instructions

3. Write Dockerfiles

4. Build and test them individually

<!--
5. Test them together with the provided Compose file
-->

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Dockerfile_Basic.md)]
---

## Code repository

Clone the repository available at:

https://github.com/jpetazzo/wordsmith

It should look like this:
```
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îî‚îÄ‚îÄ words.sql
‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îú‚îÄ‚îÄ dispatcher.go
‚îÇ   ‚îî‚îÄ‚îÄ static/
‚îî‚îÄ‚îÄ words/
    ‚îú‚îÄ‚îÄ pom.xml
    ‚îî‚îÄ‚îÄ src/
```

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Dockerfile_Basic.md)]
---

## Instructions

The repository contains instructions in English and French.
<br/>
For now, we only care about the first part (about writing Dockerfiles).
<br/>
Place each Dockerfile in its own directory, like this:
```
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îú‚îÄ‚îÄ `Dockerfile`
‚îÇ   ‚îî‚îÄ‚îÄ words.sql
‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îú‚îÄ‚îÄ `Dockerfile`
‚îÇ   ‚îú‚îÄ‚îÄ dispatcher.go
‚îÇ   ‚îî‚îÄ‚îÄ static/
‚îî‚îÄ‚îÄ words/
    ‚îú‚îÄ‚îÄ `Dockerfile`
    ‚îú‚îÄ‚îÄ pom.xml
    ‚îî‚îÄ‚îÄ src/
```

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Dockerfile_Basic.md)]
---

## Build and test

Build and run each Dockerfile individually.

For `db`, we should be able to see some messages confirming that the data set
was loaded successfully (some `INSERT` lines in the container output).

For `web` and `words`, we should be able to see some message looking like
"server started successfully".

That's all we care about for now!

Bonus question: make sure that each container stops correctly when hitting Ctrl-C.

???

## Test with a Compose file

Place the following Compose file at the root of the repository:


```yaml
version: "3"
services:
  db:
    build: db
  words:
    build: words
  web:
    build: web
    ports:
    - 8888:80
```

Test the whole app by bringin up the stack and connecting to port 8888.

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Dockerfile_Basic.md)]
---
# Exercise ‚Äî writing Dockerfiles

Let's write Dockerfiles for an existing application!

1. Check out the code repository

2. Read all the instructions

3. Write Dockerfiles

4. Build and test them individually

<!--
5. Test them together with the provided Compose file
-->

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Dockerfile_Basic.md)]
---

## Code repository

Clone the repository available at:

https://github.com/jpetazzo/wordsmith

It should look like this:
```
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îî‚îÄ‚îÄ words.sql
‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îú‚îÄ‚îÄ dispatcher.go
‚îÇ   ‚îî‚îÄ‚îÄ static/
‚îî‚îÄ‚îÄ words/
    ‚îú‚îÄ‚îÄ pom.xml
    ‚îî‚îÄ‚îÄ src/
```

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Dockerfile_Basic.md)]
---

## Instructions

The repository contains instructions in English and French.
<br/>
For now, we only care about the first part (about writing Dockerfiles).
<br/>
Place each Dockerfile in its own directory, like this:
```
‚îú‚îÄ‚îÄ LICENSE
‚îú‚îÄ‚îÄ README
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îú‚îÄ‚îÄ `Dockerfile`
‚îÇ   ‚îî‚îÄ‚îÄ words.sql
‚îú‚îÄ‚îÄ web/
‚îÇ   ‚îú‚îÄ‚îÄ `Dockerfile`
‚îÇ   ‚îú‚îÄ‚îÄ dispatcher.go
‚îÇ   ‚îî‚îÄ‚îÄ static/
‚îî‚îÄ‚îÄ words/
    ‚îú‚îÄ‚îÄ `Dockerfile`
    ‚îú‚îÄ‚îÄ pom.xml
    ‚îî‚îÄ‚îÄ src/
```

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Dockerfile_Basic.md)]
---

## Build and test

Build and run each Dockerfile individually.

For `db`, we should be able to see some messages confirming that the data set
was loaded successfully (some `INSERT` lines in the container output).

For `web` and `words`, we should be able to see some message looking like
"server started successfully".

That's all we care about for now!

Bonus question: make sure that each container stops correctly when hitting Ctrl-C.

???

## Test with a Compose file

Place the following Compose file at the root of the repository:


```yaml
version: "3"
services:
  db:
    build: db
  words:
    build: words
  web:
    build: web
    ports:
    - 8888:80
```

Test the whole app by bringin up the stack and connecting to port 8888.

.debug[[containers/Exercise_Dockerfile_Basic.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Dockerfile_Basic.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-2.jpg)]

---

name: toc-naming-and-inspecting-containers
class: title

 Naming and inspecting containers

.nav[
[Previous part](#toc-exercise--writing-dockerfiles)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-labels)
]

.debug[(automatically generated title slide)]

---

class: title

# Naming and inspecting containers

![Markings on container door](images/title-naming-and-inspecting-containers.jpg)

.debug[[containers/Naming_And_Inspecting.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Naming_And_Inspecting.md)]
---

## Objectives

In this lesson, we will learn about an important
Docker concept: container *naming*.

Naming allows us to:

* Reference easily a container.

* Ensure unicity of a specific container.

We will also see the `inspect` command, which gives a lot of details about a container.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Naming_And_Inspecting.md)]
---

## Naming our containers

So far, we have referenced containers with their ID.

We have copy-pasted the ID, or used a shortened prefix.

But each container can also be referenced by its name.

If a container is named `thumbnail-worker`, I can do:

```bash
$ docker logs thumbnail-worker
$ docker stop thumbnail-worker
etc.
```

.debug[[containers/Naming_And_Inspecting.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Naming_And_Inspecting.md)]
---

## Default names

When we create a container, if we don't give a specific
name, Docker will pick one for us.

It will be the concatenation of:

* A mood (furious, goofy, suspicious, boring...)

* The name of a famous inventor (tesla, darwin, wozniak...)

Examples: `happy_curie`, `clever_hopper`, `jovial_lovelace` ...

.debug[[containers/Naming_And_Inspecting.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Naming_And_Inspecting.md)]
---

## Specifying a name

You can set the name of the container when you create it.

```bash
$ docker run --name ticktock jpetazzo/clock
```

If you specify a name that already exists, Docker will refuse
to create the container.

This lets us enforce unicity of a given resource.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Naming_And_Inspecting.md)]
---

## Renaming containers

* You can rename containers with `docker rename`.

* This allows you to "free up" a name without destroying the associated container.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Naming_And_Inspecting.md)]
---

## Inspecting a container

The `docker inspect` command will output a very detailed JSON map.

```bash
$ docker inspect <containerID>
[{
...
(many pages of JSON here)
...
```

There are multiple ways to consume that information.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Naming_And_Inspecting.md)]
---

## Parsing JSON with the Shell

* You *could* grep and cut or awk the output of `docker inspect`.

* Please, don't.

* It's painful.

* If you really must parse JSON from the Shell, use JQ! (It's great.)

```bash
$ docker inspect <containerID> | jq .
```

* We will see a better solution which doesn't require extra tools.

.debug[[containers/Naming_And_Inspecting.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Naming_And_Inspecting.md)]
---

## Using `--format`

You can specify a format string, which will be parsed by 
Go's text/template package.

```bash
$ docker inspect --format '{{ json .Created }}' <containerID>
"2015-02-24T07:21:11.712240394Z"
```

* The generic syntax is to wrap the expression with double curly braces.

* The expression starts with a dot representing the JSON object.

* Then each field or member can be accessed in dotted notation syntax.

* The optional `json` keyword asks for valid JSON output.
  <br/>(e.g. here it adds the surrounding double-quotes.)

???

:EN:Managing container lifecycle
:EN:- Naming and inspecting containers

:FR:Suivre ses conteneurs √† la loupe
:FR:- Obtenir des informations d√©taill√©es sur un conteneur
:FR:- Associer un identifiant unique √† un conteneur

.debug[[containers/Naming_And_Inspecting.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Naming_And_Inspecting.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/two-containers-on-a-truck.jpg)]

---

name: toc-labels
class: title

 Labels

.nav[
[Previous part](#toc-naming-and-inspecting-containers)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-restarting-and-attaching-to-containers)
]

.debug[(automatically generated title slide)]

---
# Labels

* Labels allow to attach arbitrary metadata to containers.

* Labels are key/value pairs.

* They are specified at container creation.

* You can query them with `docker inspect`.

* They can also be used as filters with some commands (e.g. `docker ps`).

.debug[[containers/Labels.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Labels.md)]
---

## Using labels

Let's create a few containers with a label `owner`.

```bash
docker run -d -l owner=alice nginx
docker run -d -l owner=bob nginx
docker run -d -l owner nginx
```

We didn't specify a value for the `owner` label in the last example.

This is equivalent to setting the value to be an empty string.

.debug[[containers/Labels.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Labels.md)]
---

## Querying labels

We can view the labels with `docker inspect`.

```bash
$ docker inspect $(docker ps -lq) | grep -A3 Labels
            "Labels": {
                "maintainer": "NGINX Docker Maintainers <docker-maint@nginx.com>",
                "owner": ""
            },
```

We can use the `--format` flag to list the value of a label.

```bash
$ docker inspect $(docker ps -q) --format 'OWNER={{.Config.Labels.owner}}'
```

.debug[[containers/Labels.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Labels.md)]
---

## Using labels to select containers

We can list containers having a specific label.

```bash
$ docker ps --filter label=owner
```

Or we can list containers having a specific label with a specific value.

```bash
$ docker ps --filter label=owner=alice
```

.debug[[containers/Labels.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Labels.md)]
---

## Use-cases for labels


* HTTP vhost of a web app or web service.

  (The label is used to generate the configuration for NGINX, HAProxy, etc.)

* Backup schedule for a stateful service.

  (The label is used by a cron job to determine if/when to backup container data.)

* Service ownership.

  (To determine internal cross-billing, or who to page in case of outage.)

* etc.

???

:EN:- Using labels to identify containers
:FR:- √âtiqueter ses conteneurs avec des m√©ta-donn√©es

.debug[[containers/Labels.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Labels.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/wall-of-containers.jpeg)]

---

name: toc-restarting-and-attaching-to-containers
class: title

 Restarting and attaching to containers

.nav[
[Previous part](#toc-labels)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-getting-inside-a-container)
]

.debug[(automatically generated title slide)]

---
# Restarting and attaching to containers

We have started containers in the foreground, and in the background.

In this chapter, we will see how to:

* Put a container in the background.
* Attach to a background container to bring it to the foreground.
* Restart a stopped container.

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

## Background and foreground

The distinction between foreground and background containers is arbitrary.

From Docker's point of view, all containers are the same.

All containers run the same way, whether there is a client attached to them or not.

It is always possible to detach from a container, and to reattach to a container.

Analogy: attaching to a container is like plugging a keyboard and screen to a physical server.

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

## Detaching from a container (Linux/macOS)

* If you have started an *interactive* container (with option `-it`), you can detach from it.

* The "detach" sequence is `^P^Q`.

* Otherwise you can detach by killing the Docker client.
  
  (But not by hitting `^C`, as this would deliver `SIGINT` to the container.)

What does `-it` stand for?

* `-t` means "allocate a terminal."
* `-i` means "connect stdin to the terminal."

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

## Detaching cont. (Win PowerShell and cmd.exe)

* Docker for Windows has a different detach experience due to shell features.

* `^P^Q` does not work.

* `^C` will detach, rather than stop the container.

* Using Bash, Subsystem for Linux, etc. on Windows behaves like Linux/macOS shells.

* Both PowerShell and Bash work well in Win 10; just be aware of differences.

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

class: extra-details

## Specifying a custom detach sequence

* You don't like `^P^Q`? No problem!
* You can change the sequence with `docker run --detach-keys`.
* This can also be passed as a global option to the engine.

Start a container with a custom detach command:

```bash
$ docker run -ti --detach-keys ctrl-x,x jpetazzo/clock
```

Detach by hitting `^X x`. (This is ctrl-x then x, not ctrl-x twice!)

Check that our container is still running:

```bash
$ docker ps -l
```

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

class: extra-details

## Attaching to a container

You can attach to a container:

```bash
$ docker attach <containerID>
```

* The container must be running.
* There *can* be multiple clients attached to the same container.
* If you don't specify `--detach-keys` when attaching, it defaults back to `^P^Q`.

Try it on our previous container:

```bash
$ docker attach $(docker ps -lq)
```

Check that `^X x` doesn't work, but `^P ^Q` does.

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

## Detaching from non-interactive containers

* **Warning:** if the container was started without `-it`...

  * You won't be able to detach with `^P^Q`.
  * If you hit `^C`, the signal will be proxied to the container.

* Remember: you can always detach by killing the Docker client.

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

## Checking container output

* Use `docker attach` if you intend to send input to the container.

* If you just want to see the output of a container, use `docker logs`.

```bash
$ docker logs --tail 1 --follow <containerID>
```

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

## Restarting a container

When a container has exited, it is in stopped state.

It can then be restarted with the `start` command.

```bash
$ docker start <yourContainerID>
```

The container will be restarted using the same options you launched it
with.

You can re-attach to it if you want to interact with it:

```bash
$ docker attach <yourContainerID>
```

Use `docker ps -a` to identify the container ID of a previous `jpetazzo/clock` container,
and try those commands.

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

## Attaching to a REPL

* REPL = Read Eval Print Loop

* Shells, interpreters, TUI ...

* Symptom: you `docker attach`, and see nothing

* The REPL doesn't know that you just attached, and doesn't print anything

* Try hitting `^L` or `Enter`

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

class: extra-details

## SIGWINCH

* When you `docker attach`, the Docker Engine sends SIGWINCH signals to the container.

* SIGWINCH = WINdow CHange; indicates a change in window size.

* This will cause some CLI and TUI programs to redraw the screen.

* But not all of them.

???

:EN:- Restarting old containers
:EN:- Detaching and reattaching to container
:FR:- Red√©marrer des anciens conteneurs
:FR:- Se d√©tacher et rattacher √† des conteneurs

.debug[[containers/Start_And_Attach.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Start_And_Attach.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/catene-de-conteneurs.jpg)]

---

name: toc-getting-inside-a-container
class: title

 Getting inside a container

.nav[
[Previous part](#toc-restarting-and-attaching-to-containers)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-limiting-resources)
]

.debug[(automatically generated title slide)]

---

class: title

# Getting inside a container

![Person standing inside a container](images/getting-inside.png)

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Objectives

On a traditional server or VM, we sometimes need to:

* log into the machine (with SSH or on the console),

* analyze the disks (by removing them or rebooting with a rescue system).

In this chapter, we will see how to do that with containers.

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Getting a shell

Every once in a while, we want to log into a machine.

In an perfect world, this shouldn't be necessary.

* You need to install or update packages (and their configuration)?

  Use configuration management. (e.g. Ansible, Chef, Puppet, Salt...)

* You need to view logs and metrics?

  Collect and access them through a centralized platform.

In the real world, though ... we often need shell access!

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Not getting a shell

Even without a perfect deployment system, we can do many operations without getting a shell.

* Installing packages can (and should) be done in the container image.

* Configuration can be done at the image level, or when the container starts.

* Dynamic configuration can be stored in a volume (shared with another container).

* Logs written to stdout are automatically collected by the Docker Engine.

* Other logs can be written to a shared volume.

* Process information and metrics are visible from the host.

_Let's save logging, volumes ... for later, but let's have a look at process information!_

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Viewing container processes from the host

If you run Docker on Linux, container processes are visible on the host.

```bash
$ ps faux | less
```

* Scroll around the output of this command.

* You should see the `jpetazzo/clock` container.

* A containerized process is just like any other process on the host.

* We can use tools like `lsof`, `strace`, `gdb` ... To analyze them.

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

class: extra-details

## What's the difference between a container process and a host process?

* Each process (containerized or not) belongs to *namespaces* and *cgroups*.

* The namespaces and cgroups determine what a process can "see" and "do".

* Analogy: each process (containerized or not) runs with a specific UID (user ID).

* UID=0 is root, and has elevated privileges. Other UIDs are normal users.

_We will give more details about namespaces and cgroups later._

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Getting a shell in a running container

* Sometimes, we need to get a shell anyway.

* We _could_ run some SSH server in the container ...

* But it is easier to use `docker exec`.

```bash
$ docker exec -ti ticktock sh
```

* This creates a new process (running `sh`) _inside_ the container.

* This can also be done "manually" with the tool `nsenter`.

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Caveats

* The tool that you want to run needs to exist in the container.

* Some tools (like `ip netns exec`) let you attach to _one_ namespace at a time.

  (This lets you e.g. setup network interfaces, even if you don't have `ifconfig` or `ip` in the container.)

* Most importantly: the container needs to be running.

* What if the container is stopped or crashed?

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Getting a shell in a stopped container

* A stopped container is only _storage_ (like a disk drive).

* We cannot SSH into a disk drive or USB stick!

* We need to connect the disk to a running machine.

* How does that translate into the container world?

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Analyzing a stopped container

As an exercise, we are going to try to find out what's wrong with `jpetazzo/crashtest`.

```bash
docker run jpetazzo/crashtest
```

The container starts, but then stops immediately, without any output.

What would MacGyver&trade; do?

First, let's check the status of that container.

```bash
docker ps -l
```

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Viewing filesystem changes

* We can use `docker diff` to see files that were added / changed / removed.

```bash
docker diff <container_id>
```

* The container ID was shown by `docker ps -l`.

* We can also see it with `docker ps -lq`.

* The output of `docker diff` shows some interesting log files!

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Accessing files

* We can extract files with `docker cp`.

```bash
docker cp <container_id>:/var/log/nginx/error.log .
```

* Then we can look at that log file.

```bash
cat error.log
```

(The directory `/run/nginx` doesn't exist.)

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

## Exploring a crashed container

* We can restart a container with `docker start` ...

* ... But it will probably crash again immediately!

* We cannot specify a different program to run with `docker start`

* But we can create a new image from the crashed container

```bash
docker commit <container_id> debugimage
```

* Then we can run a new container from that image, with a custom entrypoint

```bash
docker run -ti --entrypoint sh debugimage
```

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

class: extra-details

## Obtaining a complete dump

* We can also dump the entire filesystem of a container.

* This is done with `docker export`.

* It generates a tar archive.

```bash
docker export <container_id> | tar tv
```

This will give a detailed listing of the content of the container.

???

:EN:- Troubleshooting and getting inside a container
:FR:- Inspecter un conteneur en d√©tail, en *live* ou *post-mortem*

.debug[[containers/Getting_Inside.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Getting_Inside.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-limiting-resources
class: title

 Limiting resources

.nav[
[Previous part](#toc-getting-inside-a-container)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-container-networking-basics)
]

.debug[(automatically generated title slide)]

---
# Limiting resources

- So far, we have used containers as convenient units of deployment.

- What happens when a container tries to use more resources than available?

  (RAM, CPU, disk usage, disk and network I/O...)

- What happens when multiple containers compete for the same resource?

- Can we limit resources available to a container?

  (Spoiler alert: yes!)

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Container processes are normal processes

- Containers are closer to "fancy processes" than to "lightweight VMs".

- A process running in a container is, in fact, a process running on the host.

- Let's look at the output of `ps` on a container host running 3 containers :

  ```
       0  2662  0.2  0.3 /usr/bin/dockerd -H fd://
       0  2766  0.1  0.1  \_ docker-containerd --config /var/run/docker/containe
       0 23479  0.0  0.0      \_ docker-containerd-shim -namespace moby -workdir
       0 23497  0.0  0.0      |   \_ `nginx`: master process nginx -g daemon off;
     101 23543  0.0  0.0      |       \_ `nginx`: worker process
       0 23565  0.0  0.0      \_ docker-containerd-shim -namespace moby -workdir
     102 23584  9.4 11.3      |   \_ `/docker-java-home/jre/bin/java` -Xms2g -Xmx2
       0 23707  0.0  0.0      \_ docker-containerd-shim -namespace moby -workdir
       0 23725  0.0  0.0          \_ `/bin/sh`
  ```

- The highlighted processes are containerized processes.
  <br/>
  (That host is running nginx, elasticsearch, and alpine.)

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## By default: nothing changes

- What happens when a process uses too much memory on a Linux system?

--

- Simplified answer:

  - swap is used (if available);

  - if there is not enough swap space, eventually, the out-of-memory killer is invoked;

  - the OOM killer uses heuristics to kill processes;

  - sometimes, it kills an unrelated process.

--

- What happens when a container uses too much memory?

- The same thing!

  (i.e., a process eventually gets killed, possibly in another container.)

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Limiting container resources

- The Linux kernel offers rich mechanisms to limit container resources.

- For memory usage, the mechanism is part of the *cgroup* subsystem.

- This subsystem allows limiting the memory for a process or a group of processes.

- A container engine leverages these mechanisms to limit memory for a container.

- The out-of-memory killer has a new behavior:

  - it runs when a container exceeds its allowed memory usage,

  - in that case, it only kills processes in that container.

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Limiting memory in practice

- The Docker Engine offers multiple flags to limit memory usage.

- The two most useful ones are `--memory` and `--memory-swap`.

- `--memory` limits the amount of physical RAM used by a container.

- `--memory-swap` limits the total amount (RAM+swap) used by a container.

- The memory limit can be expressed in bytes, or with a unit suffix.

  (e.g.: `--memory 100m` = 100 megabytes.)

- We will see two strategies: limiting RAM usage, or limiting both

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Limiting RAM usage

Example:

```bash
docker run -ti --memory 100m python
```

If the container tries to use more than 100 MB of RAM, *and* swap is available:

- the container will not be killed,

- memory above 100 MB will be swapped out,

- in most cases, the app in the container will be slowed down (a lot).

If we run out of swap, the global OOM killer still intervenes.

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Limiting both RAM and swap usage

Example:

```bash
docker run -ti --memory 100m --memory-swap 100m python
```

If the container tries to use more than 100 MB of memory, it is killed.

On the other hand, the application will never be slowed down because of swap.

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## When to pick which strategy?

- Stateful services (like databases) will lose or corrupt data when killed

- Allow them to use swap space, but monitor swap usage

- Stateless services can usually be killed with little impact

- Limit their mem+swap usage, but monitor if they get killed

- Ultimately, this is no different from "do I want swap, and how much?"

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Limiting CPU usage

- There are no less than 3 ways to limit CPU usage:

  - setting a relative priority with `--cpu-shares`,

  - setting a CPU% limit with `--cpus`,

  - pinning a container to specific CPUs with `--cpuset-cpus`.

- They can be used separately or together.

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Setting relative priority

- Each container has a relative priority used by the Linux scheduler.

- By default, this priority is 1024.

- As long as CPU usage is not maxed out, this has no effect.

- When CPU usage is maxed out, each container receives CPU cycles in proportion of its relative priority.

- In other words: a container with `--cpu-shares 2048` will receive twice as much than the default.

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Setting a CPU% limit

- This setting will make sure that a container doesn't use more than a given % of CPU.

- The value is expressed in CPUs; therefore:

  `--cpus 0.1` means 10% of one CPU,

  `--cpus 1.0` means 100% of one whole CPU,

  `--cpus 10.0` means 10 entire CPUs.

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Pinning containers to CPUs

- On multi-core machines, it is possible to restrict the execution on a set of CPUs.

- Examples:

  `--cpuset-cpus 0` forces the container to run on CPU 0;

  `--cpuset-cpus 3,5,7` restricts the container to CPUs 3, 5, 7;

  `--cpuset-cpus 0-3,8-11` restricts the container to CPUs 0, 1, 2, 3, 8, 9, 10, 11.

- This will not reserve the corresponding CPUs!

  (They might still be used by other containers, or uncontainerized processes.)

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

## Limiting disk usage

- Most storage drivers do not support limiting the disk usage of containers.

  (With the exception of devicemapper, but the limit cannot be set easily.)
 
- This means that a single container could exhaust disk space for everyone.

- In practice, however, this is not a concern, because:

  - data files (for stateful services) should reside on volumes,

  - assets (e.g. images, user-generated content...) should reside on object stores or on volume,

  - logs are written on standard output and gathered by the container engine.

- Container disk usage can be audited with `docker ps -s` and `docker diff`.

.debug[[containers/Resource_Limits.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Resource_Limits.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-container-networking-basics
class: title

 Container networking basics

.nav[
[Previous part](#toc-limiting-resources)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-container-network-drivers)
]

.debug[(automatically generated title slide)]

---

class: title

# Container networking basics

![A dense graph network](images/title-container-networking-basics.jpg)

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Objectives

We will now run network services (accepting requests) in containers.

At the end of this section, you will be able to:

* Run a network service in a container.

* Connect to that network service.

* Find a container's IP address.

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Running a very simple service

- We need something small, simple, easy to configure

  (or, even better, that doesn't require any configuration at all)

- Let's use the official NGINX image (named `nginx`)

- It runs a static web server listening on port 80

- It serves a default "Welcome to nginx!" page

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Running an NGINX server

```bash
$ docker run -d -P nginx
66b1ce719198711292c8f34f84a7b68c3876cf9f67015e752b94e189d35a204e
```

- Docker will automatically pull the `nginx` image from the Docker Hub

- `-d` / `--detach` tells Docker to run it in the background

- `P` / `--publish-all` tells Docker to publish all ports

  (publish = make them reachable from other computers)

- ...OK, how do we connect to our web server now?

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Finding our web server port

- First, we need to find the *port number* used by Docker

  (the NGINX container listens on port 80, but this port will be *mapped*)

- We can use `docker ps`:
  ```bash
  $ docker ps
  CONTAINER ID  IMAGE  ...  PORTS                  ...
  e40ffb406c9e  nginx  ...  0.0.0.0:`12345`->80/tcp  ...
  ```

- This means:

  *port 12345 on the Docker host is mapped to port 80 in the container*

- Now we need to connect to the Docker host!

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Finding the address of the Docker host

- When running Docker on your Linux workstation:

  *use `localhost`, or any IP address of your machine*

- When running Docker on a remote Linux server:

  *use any IP address of the remote machine*

- When running Docker Desktop on Mac or Windows:

  *use `localhost`*

- In other scenarios (`docker-machine`, local VM...):

  *use the IP address of the Docker VM*
  
.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Connecting to our web server (GUI)

Point your browser to the IP address of your Docker host, on the port
shown by `docker ps` for container port 80.

![Screenshot](images/welcome-to-nginx.png)

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Connecting to our web server (CLI)

You can also use `curl` directly from the Docker host.

Make sure to use the right port number if it is different
from the example below:

```bash
$ curl localhost:12345
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
...
```

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## How does Docker know which port to map?

* There is metadata in the image telling "this image has something on port 80".

* We can see that metadata with `docker inspect`:

```bash
$ docker inspect --format '{{.Config.ExposedPorts}}' nginx
map[80/tcp:{}]
```

* This metadata was set in the Dockerfile, with the `EXPOSE` keyword.

* We can see that with `docker history`:

```bash
$ docker history nginx
IMAGE               CREATED             CREATED BY
7f70b30f2cc6        11 days ago         /bin/sh -c #(nop)  CMD ["nginx" "-g" "‚Ä¶
<missing>           11 days ago         /bin/sh -c #(nop)  STOPSIGNAL [SIGTERM]
<missing>           11 days ago         /bin/sh -c #(nop)  EXPOSE 80/tcp
```

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Why can't we just connect to port 80?

- Our Docker host has only one port 80

- Therefore, we can only have one container at a time on port 80

- Therefore, if multiple containers want port 80, only one can get it

- By default, containers *do not* get "their" port number, but a random one

  (not "random" as "crypto random", but as "it depends on various factors")

- We'll see later how to force a port number (including port 80!)

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

class: extra-details

## Using multiple IP addresses

*Hey, my network-fu is strong, and I have questions...*

- Can I publish one container on 127.0.0.2:80, and another on 127.0.0.3:80?

- My machine has multiple (public) IP addresses, let's say A.A.A.A and B.B.B.B.
  <br/>
  Can I have one container on A.A.A.A:80 and another on B.B.B.B:80?

- I have a whole IPV4 subnet, can I allocate it to my containers?

- What about IPV6?

You can do all these things when running Docker directly on Linux.

(On other platforms, *generally not*, but there are some exceptions.)

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Finding the web server port in a script

Parsing the output of `docker ps` would be painful.

There is a command to help us:

```bash
$ docker port <containerID> 80
0.0.0.0:12345
```

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Manual allocation of port numbers

If you want to set port numbers yourself, no problem:

```bash
$ docker run -d -p 80:80 nginx
$ docker run -d -p 8000:80 nginx
$ docker run -d -p 8080:80 -p 8888:80 nginx
```

* We are running three NGINX web servers.
* The first one is exposed on port 80.
* The second one is exposed on port 8000.
* The third one is exposed on ports 8080 and 8888.

Note: the convention is `port-on-host:port-on-container`.

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Plumbing containers into your infrastructure

There are many ways to integrate containers in your network.

* Start the container, letting Docker allocate a public port for it.
  <br/>Then retrieve that port number and feed it to your configuration.

* Pick a fixed port number in advance, when you generate your configuration.
  <br/>Then start your container by setting the port numbers manually.

* Use an orchestrator like Kubernetes or Swarm.
  <br/>The orchestrator will provide its own networking facilities.

Orchestrators typically provide mechanisms to enable direct container-to-container
communication across hosts, and publishing/load balancing for inbound traffic.

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Finding the container's IP address

We can use the `docker inspect` command to find the IP address of the
container.

```bash
$ docker inspect --format '{{ .NetworkSettings.IPAddress }}' <yourContainerID>
172.17.0.3
```

* `docker inspect` is an advanced command, that can retrieve a ton
  of information about our containers.

* Here, we provide it with a format string to extract exactly the
  private IP address of the container.

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Pinging our container

Let's try to ping our container *from another container.*

```bash
docker run alpine ping `<ipaddress>`
PING 172.17.0.X (172.17.0.X): 56 data bytes
64 bytes from 172.17.0.X: seq=0 ttl=64 time=0.106 ms
64 bytes from 172.17.0.X: seq=1 ttl=64 time=0.250 ms
64 bytes from 172.17.0.X: seq=2 ttl=64 time=0.188 ms
```

When running on Linux, we can even ping that IP address directly!

(And connect to a container's ports even if they aren't published.)

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## How often do we use `-p` and `-P` ?

- When running a stack of containers, we will often use Compose

- Compose will take care of exposing containers

  (through a `ports:` section in the `docker-compose.yml` file)

- It is, however, fairly common to use `docker run -P` for a quick test

- Or `docker run -p ...` when an image doesn't `EXPOSE` a port correctly

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

## Section summary

We've learned how to:

* Expose a network port.

* Connect to an application running in a container.

* Find a container's IP address.

???

:EN:- Exposing single containers
:FR:- Exposer un conteneur isol√©

.debug[[containers/Container_Networking_Basics.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Networking_Basics.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-container-network-drivers
class: title

 Container network drivers

.nav[
[Previous part](#toc-container-networking-basics)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-the-container-network-model)
]

.debug[(automatically generated title slide)]

---
# Container network drivers

The Docker Engine supports different network drivers.

The built-in drivers include:

* `bridge` (default)

* `null` (for the special network called `none`)

* `host` (for the special network called `host`)

* `container` (that one is a bit magic!)

The network is selected with `docker run --net ...`.

Each network is managed by a driver.

The different drivers are explained with more details on the following slides.

.debug[[containers/Network_Drivers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Network_Drivers.md)]
---

## The default bridge

* By default, the container gets a virtual `eth0` interface.
  <br/>(In addition to its own private `lo` loopback interface.)

* That interface is provided by a `veth` pair.

* It is connected to the Docker bridge.
  <br/>(Named `docker0` by default; configurable with `--bridge`.)

* Addresses are allocated on a private, internal subnet.
  <br/>(Docker uses 172.17.0.0/16 by default; configurable with `--bip`.)

* Outbound traffic goes through an iptables MASQUERADE rule.

* Inbound traffic goes through an iptables DNAT rule.

* The container can have its own routes, iptables rules, etc.

.debug[[containers/Network_Drivers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Network_Drivers.md)]
---

## The null driver

* Container is started with `docker run --net none ...`

* It only gets the `lo` loopback interface. No `eth0`.

* It can't send or receive network traffic.

* Useful for isolated/untrusted workloads.

.debug[[containers/Network_Drivers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Network_Drivers.md)]
---

## The host driver

* Container is started with `docker run --net host ...`

* It sees (and can access) the network interfaces of the host.

* It can bind any address, any port (for ill and for good).

* Network traffic doesn't have to go through NAT, bridge, or veth.

* Performance = native!

Use cases:

* Performance sensitive applications (VOIP, gaming, streaming...)

* Peer discovery (e.g. Erlang port mapper, Raft, Serf...)

.debug[[containers/Network_Drivers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Network_Drivers.md)]
---

## The container driver

* Container is started with `docker run --net container:id ...`

* It re-uses the network stack of another container.

* It shares with this other container the same interfaces, IP address(es), routes, iptables rules, etc.

* Those containers can communicate over their `lo` interface.
  <br/>(i.e. one can bind to 127.0.0.1 and the others can connect to it.)

???

:EN:Advanced container networking
:EN:- Transparent network access with the "host" driver
:EN:- Sharing is caring with the "container" driver

:FR:Param√©trage r√©seau avanc√©
:FR:- Acc√®s transparent au r√©seau avec le mode "host"
:FR:- Partage de la pile r√©seau avece le mode "container"

.debug[[containers/Network_Drivers.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Network_Drivers.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/blue-containers.jpg)]

---

name: toc-the-container-network-model
class: title

 The Container Network Model

.nav[
[Previous part](#toc-container-network-drivers)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-service-discovery-with-containers)
]

.debug[(automatically generated title slide)]

---

class: title

# The Container Network Model

![A denser graph network](images/title-the-container-network-model.jpg)

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Objectives

We will learn about the CNM (Container Network Model).

At the end of this lesson, you will be able to:

* Create a private network for a group of containers.

* Use container naming to connect services together.

* Dynamically connect and disconnect containers to networks.

* Set the IP address of a container.

We will also explain the principle of overlay networks and network plugins.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## The Container Network Model

Docker has "networks".

We can manage them with the `docker network` commands; for instance:

```bash
$ docker network ls
NETWORK ID          NAME                DRIVER
6bde79dfcf70        bridge              bridge
8d9c78725538        none                null
eb0eeab782f4        host                host
4c1ff84d6d3f        blog-dev            overlay
228a4355d548        blog-prod           overlay
```

New networks can be created (with `docker network create`).

(Note: networks `none` and `host` are special; let's set them aside for now.)

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## What's a network?

- Conceptually, a Docker "network" is a virtual switch

  (we can also think about it like a VLAN, or a WiFi SSID, for instance)

- By default, containers are connected to a single network

  (but they can be connected to zero, or many networks, even dynamically)

- Each network has its own subnet (IP address range)

- A network can be local (to a single Docker Engine) or global (span multiple hosts)

- Containers can have *network aliases* providing DNS-based service discovery

  (and each network has its own "domain", "zone", or "scope")

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Service discovery

- A container can be given a network alias

  (e.g. with `docker run --net some-network --net-alias db ...`)

- The containers running in the same network can resolve that network alias

  (i.e. if they do a DNS lookup on `db`, it will give the container's address)

- We can have a different `db` container in each network

  (this avoids naming conflicts between different stacks)

- When we name a container, it automatically adds the name as a network alias

  (i.e. `docker run --name xyz ...` is like `docker run --net-alias xyz ...`

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Network isolation

- Networks are isolated

- By default, containers in network A cannot reach those in network B

- A container connected to both networks A and B can act as a router or proxy

- Published ports are always reachable through the Docker host address

  (`docker run -P ...` makes a container port available to everyone)

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## How to use networks

- We typically create one network per "stack" or app that we deploy

- More complex apps or stacks might require multiple networks

  (e.g. `frontend`, `backend`, ...)

- Networks allow us to deploy multiple copies of the same stack

  (e.g. `prod`, `dev`, `pr-442`, ....)

- If we use Docker Compose, this is managed automatically for us

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: pic

![Multiple containers on the default bridge network, on a Linux machine](images/docker-networking-default-bridge-linux.png)

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: pic

![Multiple containers in multiple bridge networks, on a Linux machine](images/docker-networking-networks-linux.png)

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: pic

![Multiple containers in multiple bridge networks, on a Mac/Windows machine](images/docker-networking-networks-macwin.png)

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## CNM vs CNI

- CNM is the model used by Docker

- Kubernetes uses a different model, architectured around CNI

  (CNI is a kind of API between a container engine and *CNI plugins*)

- Docker model:

  - multiple isolated networks
  - per-network service discovery
  - network interconnection requires extra steps

- Kubernetes model:

  - single flat network
  - per-namespace service discovery
  - network isolation requires extra steps (Network Policies)

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Creating a network

Let's create a network called `dev`.

```bash
$ docker network create dev
4c1ff84d6d3f1733d3e233ee039cac276f425a9d5228a4355d54878293a889ba
```

The network is now visible with the `network ls` command:

```bash
$ docker network ls
NETWORK ID          NAME                DRIVER
6bde79dfcf70        bridge              bridge
8d9c78725538        none                null
eb0eeab782f4        host                host
4c1ff84d6d3f        dev                 bridge
```

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Placing containers on a network

We will create a *named* container on this network.

It will be reachable with its name, `es`.

```bash
$ docker run -d --name es --net dev elasticsearch:2
8abb80e229ce8926c7223beb69699f5f34d6f1d438bfc5682db893e798046863
```

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Communication between containers

Now, create another container on this network.

.small[
```bash
$ docker run -ti --net dev alpine sh
root@0ecccdfa45ef:/#
```
]

From this new container, we can resolve and ping the other one, using its assigned name:

.small[
```bash
/ # ping es
PING es (172.18.0.2) 56(84) bytes of data.
64 bytes from es.dev (172.18.0.2): icmp_seq=1 ttl=64 time=0.221 ms
64 bytes from es.dev (172.18.0.2): icmp_seq=2 ttl=64 time=0.114 ms
64 bytes from es.dev (172.18.0.2): icmp_seq=3 ttl=64 time=0.114 ms
^C
--- es ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2000ms
rtt min/avg/max/mdev = 0.114/0.149/0.221/0.052 ms
root@0ecccdfa45ef:/#
```
]

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Resolving container addresses

Since Docker Engine 1.10, name resolution is implemented by a dynamic resolver.

Archeological note: when CNM was intoduced (in Docker Engine 1.9, November 2015)
name resolution was implemented with `/etc/hosts`, and it was updated each time
CONTAINERs were added/removed. This could cause interesting race conditions
since `/etc/hosts` was a bind-mount (and couldn't be updated atomically).

.small[
```bash
[root@0ecccdfa45ef /]# cat /etc/hosts
172.18.0.3  0ecccdfa45ef
127.0.0.1       localhost
::1     localhost ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
172.18.0.2      es
172.18.0.2      es.dev
```
]

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/chinook-helicopter-container.jpg)]

---

name: toc-service-discovery-with-containers
class: title

 Service discovery with containers

.nav[
[Previous part](#toc-the-container-network-model)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-local-development-workflow-with-docker)
]

.debug[(automatically generated title slide)]

---

# Service discovery with containers

* Let's try to run an application that requires two containers.

* The first container is a web server.

* The other one is a redis data store.

* We will place them both on the `dev` network created before.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Running the web server

* The application is provided by the container image `jpetazzo/trainingwheels`.

* We don't know much about it so we will try to run it and see what happens!

Start the container, exposing all its ports:

```bash
$ docker run --net dev -d -P jpetazzo/trainingwheels
```

Check the port that has been allocated to it:

```bash
$ docker ps -l
```

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Test the web server

* If we connect to the application now, we will see an error page:

![Trainingwheels error](images/trainingwheels-error.png)

* This is because the Redis service is not running.
* This container tries to resolve the name `redis`.

Note: we're not using a FQDN or an IP address here; just `redis`.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Start the data store

* We need to start a Redis container.

* That container must be on the same network as the web server.

* It must have the right network alias (`redis`) so the application can find it.

Start the container:

```bash
$ docker run --net dev --net-alias redis -d redis
```

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Test the web server again

* If we connect to the application now, we should see that the app is working correctly:

![Trainingwheels OK](images/trainingwheels-ok.png)

* When the app tries to resolve `redis`, instead of getting a DNS error, it gets the IP address of our Redis container.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## A few words on *scope*

- Container names are unique (there can be only one `--name redis`)

- Network aliases are not unique

- We can have the same network alias in different networks:
  ```bash
  docker run --net dev --net-alias redis ...
  docker run --net prod --net-alias redis ...
  ```

- We can even have multiple containers with the same alias in the same network

  (in that case, we get multiple DNS entries, aka "DNS round robin")

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Names are *local* to each network

Let's try to ping our `es` container from another container, when that other container is *not* on the `dev` network.

```bash
$ docker run --rm alpine ping es
ping: bad address 'es'
```

Names can be resolved only when containers are on the same network.

Containers can contact each other only when they are on the same network (you can try to ping using the IP address to verify).

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Network aliases

We would like to have another network, `prod`, with its own `es` container. But there can be only one container named `es`!

We will use *network aliases*.

A container can have multiple network aliases.

Network aliases are *local* to a given network (only exist in this network).

Multiple containers can have the same network alias (even on the same network).

Since Docker Engine 1.11, resolving a network alias yields the IP addresses of all containers holding this alias.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Creating containers on another network

Create the `prod` network.

```bash
$ docker network create prod
5a41562fecf2d8f115bedc16865f7336232a04268bdf2bd816aecca01b68d50c
```

We can now create multiple containers with the `es` alias on the new `prod` network.

```bash
$ docker run -d --name prod-es-1 --net-alias es --net prod elasticsearch:2
38079d21caf0c5533a391700d9e9e920724e89200083df73211081c8a356d771
$ docker run -d --name prod-es-2 --net-alias es --net prod elasticsearch:2
1820087a9c600f43159688050dcc164c298183e1d2e62d5694fd46b10ac3bc3d
```

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Resolving network aliases

Let's try DNS resolution first, using the `nslookup` tool that ships with the `alpine` image.

```bash
$ docker run --net prod --rm alpine nslookup es
Name:      es
Address 1: 172.23.0.3 prod-es-2.prod
Address 2: 172.23.0.2 prod-es-1.prod
```

(You can ignore the `can't resolve '(null)'` errors.)

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Connecting to aliased containers

Each ElasticSearch instance has a name (generated when it is started). This name can be seen when we issue a simple HTTP request on the ElasticSearch API endpoint.

Try the following command a few times:

.small[
```bash
$ docker run --rm --net dev centos curl -s es:9200
{
  "name" : "Tarot",
...
}
```
]

Then try it a few times by replacing `--net dev` with `--net prod`:

.small[
```bash
$ docker run --rm --net prod centos curl -s es:9200
{
  "name" : "The Symbiote",
...
}
```
]

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Good to know ...

* Docker will not create network names and aliases on the default `bridge` network.

* Therefore, if you want to use those features, you have to create a custom network first.

* Network aliases are *not* unique on a given network.

* i.e., multiple containers can have the same alias on the same network.

* In that scenario, the Docker DNS server will return multiple records.
  <br/>
  (i.e. you will get DNS round robin out of the box.)

* Enabling *Swarm Mode* gives access to clustering and load balancing with IPVS.

* Creation of networks and network aliases is generally automated with tools like Compose.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## A few words about round robin DNS

Don't rely exclusively on round robin DNS to achieve load balancing.

Many factors can affect DNS resolution, and you might see:

- all traffic going to a single instance;
- traffic being split (unevenly) between some instances;
- different behavior depending on your application language;
- different behavior depending on your base distro;
- different behavior depending on other factors (sic).

It's OK to use DNS to discover available endpoints, but remember that you have to re-resolve every now and then to discover new endpoints.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Custom networks

When creating a network, extra options can be provided.

* `--internal` disables outbound traffic (the network won't have a default gateway).

* `--gateway` indicates which address to use for the gateway (when outbound traffic is allowed).

* `--subnet` (in CIDR notation) indicates the subnet to use.

* `--ip-range` (in CIDR notation) indicates the subnet to allocate from.

* `--aux-address` allows specifying a list of reserved addresses (which won't be allocated to containers).

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Setting containers' IP address

* It is possible to set a container's address with `--ip`.
* The IP address has to be within the subnet used for the container.

A full example would look like this.

```bash
$ docker network create --subnet 10.66.0.0/16 pubnet
42fb16ec412383db6289a3e39c3c0224f395d7f85bcb1859b279e7a564d4e135
$ docker run --net pubnet --ip 10.66.66.66 -d nginx
b2887adeb5578a01fd9c55c435cad56bbbe802350711d2743691f95743680b09
```

*Note: don't hard code container IP addresses in your code!*

*I repeat: don't hard code container IP addresses in your code!*

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Network drivers

* A network is managed by a *driver*.

* The built-in drivers include:

  * `bridge` (default)
  * `none`
  * `host`
  * `macvlan`
  * `overlay` (for Swarm clusters)

* More drivers can be provided by plugins (OVS, VLAN...)

* A network can have a custom IPAM (IP allocator).

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Overlay networks

* The features we've seen so far only work when all containers are on a single host.

* If containers span multiple hosts, we need an *overlay* network to connect them together.

* Docker ships with a default network plugin, `overlay`, implementing an overlay network leveraging
  VXLAN, *enabled with Swarm Mode*.

* Other plugins (Weave, Calico...) can provide overlay networks as well.

* Once you have an overlay network, *all the features that we've used in this chapter work identically
  across multiple hosts.*

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Multi-host networking (overlay)

Out of the scope for this intro-level workshop!

Very short instructions:

- enable Swarm Mode (`docker swarm init` then `docker swarm join` on other nodes)
- `docker network create mynet --driver overlay`
- `docker service create --network mynet myimage`

If you want to learn more about Swarm mode, you can check
[this video](https://www.youtube.com/watch?v=EuzoEaE6Cqs)
or [these slides](https://container.training/swarm-selfpaced.yml.html).

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Multi-host networking (plugins)

Out of the scope for this intro-level workshop!

General idea:

- install the plugin (they often ship within containers)

- run the plugin (if it's in a container, it will often require extra parameters; don't just `docker run` it blindly!)

- some plugins require configuration or activation (creating a special file that tells Docker "use the plugin whose control socket is at the following location")

- you can then `docker network create --driver pluginname`

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Connecting and disconnecting dynamically

* So far, we have specified which network to use when starting the container.

* The Docker Engine also allows connecting and disconnecting while the container is running.

* This feature is exposed through the Docker API, and through two Docker CLI commands:

  * `docker network connect <network> <container>`

  * `docker network disconnect <network> <container>`

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Dynamically connecting to a network

* We have a container named `es` connected to a network named `dev`.

* Let's start a simple alpine container on the default network:

  ```bash
  $ docker run -ti alpine sh
  / #
  ```

* In this container, try to ping the `es` container:

  ```bash
  / # ping es
  ping: bad address 'es'
  ```

  This doesn't work, but we will change that by connecting the container.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Finding the container ID and connecting it

* Figure out the ID of our alpine container; here are two methods:

  * looking at `/etc/hostname` in the container,

  * running `docker ps -lq` on the host.

* Run the following command on the host:

  ```bash
  $ docker network connect dev `<container_id>`
  ```

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Checking what we did

* Try again to `ping es` from the container.

* It should now work correctly:

  ```bash
  / # ping es
  PING es (172.20.0.3): 56 data bytes
  64 bytes from 172.20.0.3: seq=0 ttl=64 time=0.376 ms
  64 bytes from 172.20.0.3: seq=1 ttl=64 time=0.130 ms
  ^C
  ```

* Interrupt it with Ctrl-C.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Looking at the network setup in the container

We can look at the list of network interfaces with `ifconfig`, `ip a`, or `ip l`:

.small[
```bash
/ # ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
18: eth0@if19: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever
20: eth1@if21: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP
    link/ether 02:42:ac:14:00:04 brd ff:ff:ff:ff:ff:ff
    inet 172.20.0.4/16 brd 172.20.255.255 scope global eth1
       valid_lft forever preferred_lft forever
/ #
```
]

Each network connection is materialized with a virtual network interface.

As we can see, we can be connected to multiple networks at the same time.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

## Disconnecting from a network

* Let's try the symmetrical command to disconnect the container:
  ```bash
  $ docker network disconnect dev <container_id>
  ```

* From now on, if we try to ping `es`, it will not resolve:
  ```bash
  / # ping es
  ping: bad address 'es'
  ```

* Trying to ping the IP address directly won't work either:
  ```bash
  / # ping 172.20.0.3
  ... (nothing happens until we interrupt it with Ctrl-C)
  ```

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Network aliases are scoped per network

* Each network has its own set of network aliases.

* We saw this earlier: `es` resolves to different addresses in `dev` and `prod`.

* If we are connected to multiple networks, the resolver looks up names in each of them
  (as of Docker Engine 18.03, it is the connection order) and stops as soon as the name
  is found.

* Therefore, if we are connected to both `dev` and `prod`, resolving `es` will **not**
  give us the addresses of all the `es` services; but only the ones in `dev` or `prod`.

* However, we can lookup `es.dev` or `es.prod` if we need to.

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Finding out about our networks and names

* We can do reverse DNS lookups on containers' IP addresses.

* If the IP address belongs to a network (other than the default bridge), the result will be:

  ```
  name-or-first-alias-or-container-id.network-name
  ```

* Example:

.small[
```bash
$ docker run -ti --net prod --net-alias hello alpine
/ # apk add --no-cache drill
...
OK: 5 MiB in 13 packages
/ # ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:15:00:03
          inet addr:`172.21.0.3`  Bcast:172.21.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
...
/ # drill -t ptr `3.0.21.172`.in-addr.arpa
...
;; ANSWER SECTION:
3.0.21.172.in-addr.arpa.	600	IN	PTR	`hello.prod`.
...
```
]

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: extra-details

## Building with a custom network

* We can build a Dockerfile with a custom network with `docker build --network NAME`.

* This can be used to check that a build doesn't access the network.

  (But keep in mind that most Dockerfiles will fail,
  <br/>because they need to install remote packages and dependencies!)

* This may be used to access an internal package repository.

  (But try to use a multi-stage build instead, if possible!)

???

:EN:Container networking essentials
:EN:- The Container Network Model
:EN:- Container isolation
:EN:- Service discovery

:FR:Mettre ses conteneurs en r√©seau
:FR:- Le "Container Network Model"
:FR:- Isolation des conteneurs
:FR:- *Service discovery*

.debug[[containers/Container_Network_Model.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Container_Network_Model.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-cranes.jpg)]

---

name: toc-local-development-workflow-with-docker
class: title

 Local development workflow with Docker

.nav[
[Previous part](#toc-service-discovery-with-containers)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-working-with-volumes)
]

.debug[(automatically generated title slide)]

---

class: title

# Local development workflow with Docker

![Construction site](images/title-local-development-workflow-with-docker.jpg)

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Objectives

At the end of this section, you will be able to:

* Share code between container and host.

* Use a simple local development workflow.

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Local development in a container

We want to solve the following issues:

- "Works on my machine"

- "Not the same version"

- "Missing dependency"

By using Docker containers, we will get a consistent development environment.

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Working on the "namer" application

* We have to work on some application whose code is at:

  https://github.com/jpetazzo/namer.

* What is it? We don't know yet!

* Let's download the code.

```bash
$ git clone https://github.com/jpetazzo/namer
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Looking at the code

```bash
$ cd namer
$ ls -1
company_name_generator.rb
config.ru
docker-compose.yml
Dockerfile
Gemfile
```

--

Aha, a `Gemfile`! This is Ruby. Probably. We know this. Maybe?

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Looking at the `Dockerfile`

```dockerfile
FROM ruby

COPY . /src
WORKDIR /src
RUN bundler install

CMD ["rackup", "--host", "0.0.0.0"]
EXPOSE 9292
```

* This application is using a base `ruby` image.
* The code is copied in `/src`.
* Dependencies are installed with `bundler`.
* The application is started with `rackup`.
* It is listening on port 9292.

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Building and running the "namer" application

* Let's build the application with the `Dockerfile`!

--

```bash
$ docker build -t namer .
```

--

* Then run it. *We need to expose its ports.*

--

```bash
$ docker run -dP namer
```

--

* Check on which port the container is listening.

--

```bash
$ docker ps -l
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Connecting to our application

* Point our browser to our Docker node, on the port allocated to the container.

--

* Hit "reload" a few times.

--

* This is an enterprise-class, carrier-grade, ISO-compliant company name generator!

  (With 50% more bullshit than the average competition!)

  (Wait, was that 50% more, or 50% less? *Anyway!*)

  ![web application 1](images/webapp-in-blue.png)

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Making changes to the code

Option 1:

* Edit the code locally
* Rebuild the image
* Re-run the container

Option 2:

* Enter the container (with `docker exec`)
* Install an editor
* Make changes from within the container

Option 3:

* Use a *bind mount* to share local files with the container
* Make changes locally
* Changes are reflected in the container

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Our first volume

We will tell Docker to map the current directory to `/src` in the container.

```bash
$ docker run -d -v $(pwd):/src -P namer
```

* `-d`: the container should run in detached mode (in the background).

* `-v`: the following host directory should be mounted inside the container.

* `-P`: publish all the ports exposed by this image.

* `namer` is the name of the image we will run.

* We don't specify a command to run because it is already set in the Dockerfile via `CMD`.

Note: on Windows, replace `$(pwd)` with `%cd%` (or `${pwd}` if you use PowerShell).

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Mounting volumes inside containers

The `-v` flag mounts a directory from your host into your Docker container.

The flag structure is:

```bash
[host-path]:[container-path]:[rw|ro]
```

* `[host-path]` and `[container-path]` are created if they don't exist.

* You can control the write status of the volume with the `ro` and
  `rw` options.

* If you don't specify `rw` or `ro`, it will be `rw` by default.

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## Hold your horses... and your mounts

- The `-v /path/on/host:/path/in/container` syntax is the "old" syntax

- The modern syntax looks like this:

  `--mount type=bind,source=/path/on/host,target=/path/in/container`

- `--mount` is more explicit, but `-v` is quicker to type

- `--mount` supports all mount types; `-v` doesn't support `tmpfs` mounts

- `--mount` fails if the path on the host doesn't exist; `-v` creates it

With the new syntax, our command becomes:
```bash
docker run --mount=type=bind,source=$(pwd),target=/src -dP namer
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Testing the development container

* Check the port used by our new container.

```bash
$ docker ps -l
CONTAINER ID  IMAGE  COMMAND  CREATED        STATUS  PORTS                   NAMES
045885b68bc5  namer  rackup   3 seconds ago  Up ...  0.0.0.0:32770->9292/tcp ...
```

* Open the application in your web browser.

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Making a change to our application

Our customer really doesn't like the color of our text. Let's change it.

```bash
$ vi company_name_generator.rb
```

And change

```css
color: royalblue;
```

To:

```css
color: red;
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Viewing our changes

* Reload the application in our browser.

--

* The color should have changed.

  ![web application 2](images/webapp-in-red.png)

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Understanding volumes

- Volumes are *not* copying or synchronizing files between the host and the container

- Changes made in the host are immediately visible in the container (and vice versa)

- When running on Linux:

  - volumes and bind mounts correspond to directories on the host

  - if Docker runs in a Linux VM, these directories are in the Linux VM

- When running on Docker Desktop:

  - volumes correspond to directories in a small Linux VM running Docker

  - access to bind mounts is translated to host filesystem access
    <br/>
    (a bit like a network filesystem)

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## Docker Desktop caveats

- When running Docker natively on Linux, accessing a mount = native I/O

- When running Docker Desktop, accessing a bind mount = file access translation

- That file access translation has relatively good performance *in general*

  (watch out, however, for that big `npm install` working on a bind mount!)

- There are some corner cases when watching files (with mechanisms like inotify)

- Features like "live reload" or programs like `entr` don't always behave properly

  (due to e.g. file attribute caching, and other interesting details!)

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Trash your servers and burn your code

*(This is the title of a
[2013 blog post][immutable-deployments]
by Chad Fowler, where he explains the concept of immutable infrastructure.)*

[immutable-deployments]: https://web.archive.org/web/20160305073617/http://chadfowler.com/blog/2013/06/23/immutable-deployments/

--

* Let's majorly mess up our container.

  (Remove files or whatever.)

* Now, how can we fix this?

--

* Our old container (with the blue version of the code) is still running.

* See on which port it is exposed:
  ```bash
  docker ps
  ```

* Point our browser to it to confirm that it still works fine.

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Immutable infrastructure in a nutshell

* Instead of *updating* a server, we deploy a new one.

* This might be challenging with classical servers, but it's trivial with containers.

* In fact, with Docker, the most logical workflow is to build a new image and run it.

* If something goes wrong with the new image, we can always restart the old one.

* We can even keep both versions running side by side.

If this pattern sounds interesting, you might want to read about *blue/green deployment*
and *canary deployments*.

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Recap of the development workflow

1. Write a Dockerfile to build an image containing our development environment.
   <br/>
   (Rails, Django, ... and all the dependencies for our app)

2. Start a container from that image.
   <br/>
   Use the `-v` flag to mount our source code inside the container.

3. Edit the source code outside the container, using familiar tools.
   <br/>
   (vim, emacs, textmate...)

4. Test the application.
   <br/>
   (Some frameworks pick up changes automatically.
   <br/>Others require you to Ctrl-C + restart after each modification.)

5. Iterate and repeat steps 3 and 4 until satisfied.

6. When done, commit+push source code changes.

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## Debugging inside the container

Docker has a command called `docker exec`.

It allows users to run a new process in a container which is already running.

If sometimes you find yourself wishing you could SSH into a container: you can use `docker exec` instead.

You can get a shell prompt inside an existing container this way, or run an arbitrary process for automation.

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## `docker exec` example

```bash
$ # You can run ruby commands in the area the app is running and more!
$ docker exec -it <yourContainerId> bash
root@5ca27cf74c2e:/opt/namer# irb
irb(main):001:0> [0, 1, 2, 3, 4].map {|x| x ** 2}.compact
=> [0, 1, 4, 9, 16]
irb(main):002:0> exit
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

class: extra-details

## Stopping the container

Now that we're done let's stop our container.

```bash
$ docker stop <yourContainerID>
```

And remove it.

```bash
$ docker rm <yourContainerID>
```

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

## Section summary

We've learned how to:

* Share code between container and host.

* Set our working directory.

* Use a simple local development workflow.

???

:EN:Developing with containers
:EN:- ‚ÄúContainerize‚Äù a development environment

:FR:D√©velopper au jour le jour
:FR:- ¬´ Containeriser ¬ª son environnement de d√©veloppement

.debug[[containers/Local_Development_Workflow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Local_Development_Workflow.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/container-housing.jpg)]

---

name: toc-working-with-volumes
class: title

 Working with volumes

.nav[
[Previous part](#toc-local-development-workflow-with-docker)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-gentle-introduction-to-yaml)
]

.debug[(automatically generated title slide)]

---

class: title

# Working with volumes

![volume](images/title-working-with-volumes.jpg)

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Objectives

At the end of this section, you will be able to:

* Create containers holding volumes.

* Share volumes across containers.

* Share a host directory with one or many containers.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Working with volumes

Docker volumes can be used to achieve many things, including:

* Bypassing the copy-on-write system to obtain native disk I/O performance.

* Bypassing copy-on-write to leave some files out of `docker commit`.

* Sharing a directory between multiple containers.

* Sharing a directory between the host and a container.

* Sharing a *single file* between the host and a container.

* Using remote storage and custom storage with *volume drivers*.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Volumes are special directories in a container

Volumes can be declared in two different ways:

* Within a `Dockerfile`, with a `VOLUME` instruction.

```dockerfile
VOLUME /uploads
```

* On the command-line, with the `-v` flag for `docker run`.

```bash
$ docker run -d -v /uploads myapp
```

In both cases, `/uploads` (inside the container) will be a volume.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: extra-details

## Volumes bypass the copy-on-write system

Volumes act as passthroughs to the host filesystem.

* The I/O performance on a volume is exactly the same as I/O performance
  on the Docker host.

* When you `docker commit`, the content of volumes is not brought into
  the resulting image.

* If a `RUN` instruction in a `Dockerfile` changes the content of a
  volume, those changes are not recorded neither.

* If a container is started with the `--read-only` flag, the volume
  will still be writable (unless the volume is a read-only volume).

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: extra-details

## Volumes can be shared across containers

You can start a container with *exactly the same volumes* as another one.

The new container will have the same volumes, in the same directories.

They will contain exactly the same thing, and remain in sync.

Under the hood, they are actually the same directories on the host anyway.

This is done using the `--volumes-from` flag for `docker run`.

We will see an example in the following slides.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: extra-details

## Sharing app server logs with another container

Let's start a Tomcat container:

```bash
$ docker run --name webapp -d -p 8080:8080 -v /usr/local/tomcat/logs tomcat
```

Now, start an `alpine` container accessing the same volume:

```bash
$ docker run --volumes-from webapp alpine sh -c "tail -f /usr/local/tomcat/logs/*"
```

Then, from another window, send requests to our Tomcat container:
```bash
$ curl localhost:8080
```

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Volumes exist independently of containers

If a container is stopped or removed, its volumes still exist and are available.

Volumes can be listed and manipulated with `docker volume` subcommands:

```bash
$ docker volume ls
DRIVER              VOLUME NAME
local               5b0b65e4316da67c2d471086640e6005ca2264f3...
local               pgdata-prod
local               pgdata-dev
local               13b59c9936d78d109d094693446e174e5480d973...
```

Some of those volume names were explicit (pgdata-prod, pgdata-dev).

The others (the hex IDs) were generated automatically by Docker.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Naming volumes

* Volumes can be created without a container, then used in multiple containers.

Let's create a couple of volumes directly.

```bash
$ docker volume create webapps
webapps
```

```bash
$ docker volume create logs
logs
```

Volumes are not anchored to a specific path.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Populating volumes

* When an empty volume is mounted on a non-empty directory, the directory is copied to the volume.

* This makes it easy to "promote" a normal directory to a volume.

* Non-empty volumes are always mounted as-is.

Let's populate the webapps volume with the webapps.dist directory from the Tomcat image.

````bash
$ docker run -v webapps:/usr/local/tomcat/webapps.dist tomcat true
```

Note: running `true` will cause the container to exit successfully once the `webapps.dist` directory has been copied to the `webapps` volume, instead of starting tomcat.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Using our named volumes

* Volumes are used with the `-v` option.

* When a host path does not contain a `/`, it is considered a volume name.

Let's start a web server using the two previous volumes.

```bash
$ docker run -d -p 1234:8080 \
         -v logs:/usr/local/tomcat/logs \
         -v webapps:/usr/local/tomcat/webapps \
         tomcat
```

Check that it's running correctly:

```bash
$ curl localhost:1234
... (Tomcat tells us how happy it is to be up and running) ...
```

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Using a volume in another container

* We will make changes to the volume from another container.

* In this example, we will run a text editor in the other container.

  (But this could be an FTP server, a WebDAV server, a Git receiver...)

Let's start another container using the `webapps` volume.

```bash
$ docker run -v webapps:/webapps -w /webapps -ti alpine vi ROOT/index.jsp
```

Vandalize the page, save, exit.

Then run `curl localhost:1234` again to see your changes.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Using custom "bind-mounts"

In some cases, you want a specific directory on the host to be mapped
inside the container:

* You want to manage storage and snapshots yourself.

    (With LVM, or a SAN, or ZFS, or anything else!)

* You have a separate disk with better performance (SSD) or resiliency (EBS)
  than the system disk, and you want to put important data on that disk.

* You want to share your source directory between your host (where the
  source gets edited) and the container (where it is compiled or executed).

Wait, we already met the last use-case in our example development workflow!
Nice.

```bash
$ docker run -d -v /path/on/the/host:/path/in/container image ...
```

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: extra-details

## Migrating data with `--volumes-from`

The `--volumes-from` option tells Docker to re-use all the volumes
of an existing container.

* Scenario: migrating from Redis 2.8 to Redis 3.0.

* We have a container (`myredis`) running Redis 2.8.

* Stop the `myredis` container.

* Start a new container, using the Redis 3.0 image, and the `--volumes-from` option.

* The new container will inherit the data of the old one.

* Newer containers can use `--volumes-from` too.

* Doesn't work across servers, so not usable in clusters (Swarm, Kubernetes).

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: extra-details

## Data migration in practice

Let's create a Redis container.

```bash
$ docker run -d --name redis28 redis:2.8
```

Connect to the Redis container and set some data.

```bash
$ docker run -ti --link redis28:redis busybox telnet redis 6379
```

Issue the following commands:

```bash
SET counter 42
INFO server
SAVE
QUIT
```

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: extra-details

## Upgrading Redis

Stop the Redis container.

```bash
$ docker stop redis28
```

Start the new Redis container.

```bash
$ docker run -d --name redis30 --volumes-from redis28 redis:3.0
```

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: extra-details

## Testing the new Redis

Connect to the Redis container and see our data.

```bash
docker run -ti --link redis30:redis busybox telnet redis 6379
```

Issue a few commands.

```bash
GET counter
INFO server
QUIT
```

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Volumes lifecycle

* When you remove a container, its volumes are kept around.

* You can list them with `docker volume ls`.

* You can access them by creating a container with `docker run -v`.

* You can remove them with `docker volume rm` or `docker system prune`.

Ultimately, _you_ are the one responsible for logging,
monitoring, and backup of your volumes.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: extra-details

## Checking volumes defined by an image

Wondering if an image has volumes? Just use `docker inspect`:

```bash
$ # docker inspect training/datavol
[{
  "config": {
    . . .
    "Volumes": {
        "/var/webapp": {}
    },
    . . .
}]
```

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: extra-details

## Checking volumes used by a container

To look which paths are actually volumes, and to what they are bound,
use `docker inspect` (again):

```bash
$ docker inspect <yourContainerID>
[{
  "ID": "<yourContainerID>",
. . .
  "Volumes": {
     "/var/webapp": "/var/lib/docker/vfs/dir/f4280c5b6207ed531efd4cc673ff620cef2a7980f747dbbcca001db61de04468"
  },
  "VolumesRW": {
     "/var/webapp": true
  },
}]
```

* We can see that our volume is present on the file system of the Docker host.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Sharing a single file

The same `-v` flag can be used to share a single file (instead of a directory).

One of the most interesting examples is to share the Docker control socket.

```bash
$ docker run -it -v /var/run/docker.sock:/var/run/docker.sock docker sh
```

From that container, you can now run `docker` commands communicating with
the Docker Engine running on the host. Try `docker ps`!

.warning[Since that container has access to the Docker socket, it
has root-like access to the host.]

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Volume plugins

You can install plugins to manage volumes backed by particular storage systems,
or providing extra features. For instance:

* [REX-Ray](https://rexray.io/) - create and manage volumes backed by an enterprise storage system (e.g.
  SAN or NAS), or by cloud block stores (e.g. EBS, EFS).

* [Portworx](https://portworx.com/) - provides distributed block store for containers.

* [Gluster](https://www.gluster.org/) - open source software-defined distributed storage that can scale
  to several petabytes. It provides interfaces for object, block and file storage.

* and much more at the [Docker Store](https://store.docker.com/search?category=volume&q=&type=plugin)!

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Volumes vs. Mounts

* Since Docker 17.06, a new options is available: `--mount`.

* It offers a new, richer syntax to manipulate data in containers.

* It makes an explicit difference between:

  - volumes (identified with a unique name, managed by a storage plugin),

  - bind mounts (identified with a host path, not managed).

* The former `-v` / `--volume` option is still usable.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## `--mount` syntax

Binding a host path to a container path:

```bash
$ docker run \
  --mount type=bind,source=/path/on/host,target=/path/in/container alpine
```

Mounting a volume to a container path:

```bash
$ docker run \
  --mount source=myvolume,target=/path/in/container alpine
```

Mounting a tmpfs (in-memory, for temporary files):

```bash
$ docker run \
  --mount type=tmpfs,destination=/path/in/container,tmpfs-size=1000000 alpine
```

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

## Section summary

We've learned how to:

* Create and manage volumes.

* Share volumes across containers.

* Share a host directory with one or many containers.

.debug[[containers/Working_With_Volumes.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Working_With_Volumes.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/containers-by-the-water.jpg)]

---

name: toc-gentle-introduction-to-yaml
class: title

 Gentle introduction to YAML

.nav[
[Previous part](#toc-working-with-volumes)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-compose-for-development-stacks)
]

.debug[(automatically generated title slide)]

---
# Gentle introduction to YAML

- YAML Ain't Markup Language (according to [yaml.org][yaml])

- *Almost* required when working with containers:

  - Docker Compose files

  - Kubernetes manifests

  - Many CI pipelines (GitHub, GitLab...)

- If you don't know much about YAML, this is for you!

[yaml]: https://yaml.org/

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## What is it?

- Data representation language

```yaml
- country: France
  capital: Paris
  code: fr
  population: 68042591
- country: Germany
  capital: Berlin
  code: de
  population: 84270625
- country: Norway
  capital: Oslo
  code: no # It's a trap!
  population: 5425270
```

- Even without knowing YAML, we probably can add a country to that file :)

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## Trying YAML

- Method 1: in the browser

  https://onlineyamltools.com/convert-yaml-to-json

  https://onlineyamltools.com/highlight-yaml

- Method 2: in a shell

  ```bash
  yq . foo.yaml
  ```

- Method 3: in Python

  ```python
    import yaml; yaml.safe_load("""
    - country: France
      capital: Paris
    """)
  ```

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## Basic stuff

- Strings, numbers, boolean values, `null`

- Sequences (=arrays, lists)

- Mappings (=objects)

- Superset of JSON

  (if you know JSON, you can just write JSON)

- Comments start with `#`

- A single *file* can have multiple *documents*

  (separated by `---` on a single line)

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## Sequences

- Example: sequence of strings
  ```yaml
  [ "france", "germany", "norway" ]
  ```

- Example: the same sequence, without the double-quotes
  ```yaml
  [ france, germany, norway ]
  ```

- Example: the same sequence, in "block collection style" (=multi-line)
  ```yaml
  - france
  - germany
  - norway
  ```

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## Mappings

- Example: mapping strings to numbers
  ```yaml
  { "france": 68042591, "germany": 84270625, "norway": 5425270 }
  ```

- Example: the same mapping, without the double-quotes
  ```yaml
  { france: 68042591, germany: 84270625, norway: 5425270 }
  ```

- Example: the same mapping, in "block collection style"
  ```yaml
  france: 68042591
  germany: 84270625
  norway: 5425270
  ```

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## Combining types

- In a sequence (or mapping) we can have different types

  (including other sequences or mappings)

- Example:
  ```yaml
  questions: [ name, quest, favorite color ]
  answers: [ "Arthur, King of the Britons", Holy Grail, purple, 42 ]
  ```

- Note that we need to quote "Arthur" because of the comma

- Note that we don't have the same number of elements in questions and answers

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## More combinations

- Example:
  ```yaml
    - service: nginx
      ports: [ 80, 443 ]
    - service: bind
      ports: [ 53/tcp, 53/udp ]
    - service: ssh
      ports: 22
  ```

- Note that `ports` doesn't always have the same type

  (the code handling that data will probably have to be smart!)

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## ‚ö†Ô∏è Automatic booleans

```yaml
codes:
  france: fr
  germany: de
  norway: no
```

--

```json
{
  "codes": {
    "france": "fr",
    "germany": "de",
    "norway": false
  }
}
```

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## ‚ö†Ô∏è Automatic booleans

- `no` can become `false`

  (it depends on the YAML parser used)

- It should be quoted instead:

  ```yaml
    codes:
      france: fr
      germany: de
      norway: "no"
  ```

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## ‚ö†Ô∏è Automatic floats

```yaml
version:
  libfoo: 1.10
  fooctl: 1.0
```

--

```json
{
  "version": {
    "libfoo": 1.1,
    "fooctl": 1
  }
}
```

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## ‚ö†Ô∏è Automatic floats

- Trailing zeros disappear

- These should also be quoted:

  ```yaml
    version:
      libfoo: "1.10"
      fooctl: "1.0"
  ```

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## ‚ö†Ô∏è Automatic times

```yaml
portmap:
- 80:80
- 22:22
```

--

```json
{
  "portmap": [
    "80:80",
    1342
  ]
}
```

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## ‚ö†Ô∏è Automatic times

- `22:22` becomes `1342`

- Thats 22 minutes and 22 seconds = 1342 seconds

- Again, it should be quoted

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## Document separator

- A single YAML *file* can have multiple *documents* separated by `---`:

  ```yaml
    This is a document consisting of a single string.
    --- üí°
    name: The second document
    type: This one is a mapping (key‚Üívalue)
    --- üí°
    - Third document
    - This one is a sequence
  ```

- Some folks like to add an extra `---` at the beginning and/or at the end

  (it's not mandatory but can help e.g. to `cat` multiple files together)

.footnote[üí° Ignore this; it's here to work around [this issue][remarkyaml].]

[remarkyaml]: https://github.com/gnab/remark/issues/679

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

## Multi-line strings

Try the following block in a YAML parser:

```yaml
add line breaks: "in double quoted strings\n(like this)"
preserve line break: |
  by using
  a pipe (|)
  (this is great for embedding shell scripts, configuration files...)
do not preserve line breaks: >
  by using
  a greater-than (>)
  (this is great for embedding very long lines)
```

See https://yaml-multiline.info/ for advanced multi-line tips!

(E.g. to strip or keep extra `\n` characters at the end of the block.)

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

class: extra-details

## Advanced features

Anchors let you "memorize" and re-use content:

```yaml
debian: &debian
  packages: deb
  latest-stable: bullseye

also-debian: *debian

ubuntu:
  <<: *debian
  latest-stable: jammy
```

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

class: extra-details

## YAML, good or evil?

- Natural progression from XML to JSON to YAML

- There are other data languages out there

  (e.g. HCL, domain-specific things crafted with Ruby, CUE...)

- Compromises are made, for instance:

  - more user-friendly ‚Üí more "magic" with side effects

  - more powerful ‚Üí steeper learning curve

- Love it or loathe it but it's a good idea to understand it!

- Interesting tool if you appreciate YAML: https://carvel.dev/ytt/

???

:EN:- Understanding YAML and its gotchas
:FR:- Comprendre le YAML et ses subtilit√©s

.debug[[shared/yaml.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/yaml.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/distillery-containers.jpg)]

---

name: toc-compose-for-development-stacks
class: title

 Compose for development stacks

.nav[
[Previous part](#toc-gentle-introduction-to-yaml)
|
[Back to table of contents](#toc-part-2)
|
[Next part](#toc-exercise--writing-a-compose-file)
]

.debug[(automatically generated title slide)]

---
# Compose for development stacks

Dockerfile = great to build *one* container image.

What if we have multiple containers?

What if some of them require particular `docker run` parameters?

How do we connect them all together?

... Compose solves these use-cases (and a few more).

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Life before Compose

Before we had Compose, we would typically write custom scripts to:

- build container images,

- run containers using these images,

- connect the containers together,

- rebuild, restart, update these images and containers.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Life with Compose

Compose enables a simple, powerful onboarding workflow:

1. Checkout our code.

2. Run `docker-compose up`.

3. Our app is up and running!

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

class: pic

![composeup](images/composeup.gif)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Life after Compose

(Or: when do we need something else?)

- Compose is *not* an orchestrator

- It isn't designed to need to run containers on multiple nodes

  (it can, however, work with Docker Swarm Mode)

- Compose isn't ideal if we want to run containers on Kubernetes

  - it uses different concepts (Compose services ‚â† Kubernetes services)

  - it needs a Docker Engine (although containerd support might be coming)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## First rodeo with Compose

1. Write Dockerfiles

2. Describe our stack of containers in a YAML file called `docker-compose.yml`

3. `docker-compose up` (or `docker-compose up -d` to run in the background)

4. Compose pulls and builds the required images, and starts the containers

5. Compose shows the combined logs of all the containers

   (if running in the background, use `docker-compose logs`)

6. Hit Ctrl-C to stop the whole stack

   (if running in the background, use `docker-compose stop`)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Iterating

After making changes to our source code, we can:

1. `docker-compose build` to rebuild container images

2. `docker-compose up` to restart the stack with the new images

We can also combine both with `docker-compose up --build`

Compose will be smart, and only recreate the containers that have changed.

When working with interpreted languages:

- don't rebuild each time

- leverage a `volumes` section instead

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Launching Our First Stack with Compose

First step: clone the source code for the app we will be working on.

```bash
git clone https://github.com/jpetazzo/trainingwheels
cd trainingwheels
```

Second step: start the app.

```bash
docker-compose up
```

Watch Compose build and run the app.

That Compose stack exposes a web server on port 8000; try connecting to it.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Launching Our First Stack with Compose

We should see a web page like this:

![composeapp](images/composeapp.png)

Each time we reload, the counter should increase.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Stopping the app

When we hit Ctrl-C, Compose tries to gracefully terminate all of the containers.

After ten seconds (or if we press `^C` again) it will forcibly kill them.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## The `docker-compose.yml` file

Here is the file used in the demo:

.small[
```yaml
version: "3"

services:
  www:
    build: www
    ports:
      - ${PORT-8000}:5000
    user: nobody
    environment:
      DEBUG: 1
    command: python counter.py
    volumes:
      - ./www:/src

  redis:
    image: redis
```
]

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Compose file structure

A Compose file has multiple sections:

* `version` is mandatory. (Typically use "3".)

* `services` is mandatory. Each service corresponds to a container.

* `networks` is optional and indicates to which networks containers should be connected.
  <br/>(By default, containers will be connected on a private, per-compose-file network.)

* `volumes` is optional and can define volumes to be used and/or shared by the containers.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Compose file versions

* Version 1 is legacy and shouldn't be used.

  (If you see a Compose file without `version` and `services`, it's a legacy v1 file.)

* Version 2 added support for networks and volumes.

* Version 3 added support for deployment options (scaling, rolling updates, etc).

* Typically use `version: "3"`.

The [Docker documentation](https://docs.docker.com/compose/compose-file/)
has excellent information about the Compose file format if you need to know more about versions.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Containers in `docker-compose.yml`

Each service in the YAML file must contain either `build`, or `image`.

* `build` indicates a path containing a Dockerfile.

* `image` indicates an image name (local, or on a registry).

* If both are specified, an image will be built from the `build` directory and named `image`.

The other parameters are optional.

They encode the parameters that you would typically add to `docker run`.

Sometimes they have several minor improvements.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Container parameters

* `command` indicates what to run (like `CMD` in a Dockerfile).

* `ports` translates to one (or multiple) `-p` options to map ports.
  <br/>You can specify local ports (i.e. `x:y` to expose public port `x`).

* `volumes` translates to one (or multiple) `-v` options.
  <br/>You can use relative paths here.

For the full list, check: https://docs.docker.com/compose/compose-file/

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Environment variables

- We can use environment variables in Compose files

  (like `$THIS` or `${THAT}`)

- We can provide default values, e.g. `${PORT-8000}`

- Compose will also automatically load the environment file `.env`

  (it should contain `VAR=value`, one per line)

- This is a great way to customize build and run parameters

  (base image versions to use, build and run secrets, port numbers...)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Configuring a Compose stack

- Follow [12-factor app configuration principles][12factorconfig]

  (configure the app through environment variables)

- Provide (in the repo) a default environment file suitable for development

  (no secret or sensitive value)

- Copy the default environment file to `.env` and tweak it

  (or: provide a script to generate `.env` from a template)

[12factorconfig]: https://12factor.net/config

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Running multiple copies of a stack

- Copy the stack in two different directories, e.g. `front` and `frontcopy`

- Compose prefixes images and containers with the directory name:

  `front_www`, `front_www_1`, `front_db_1`

  `frontcopy_www`, `frontcopy_www_1`, `frontcopy_db_1`

- Alternatively, use `docker-compose -p frontcopy` 

  (to set the `--project-name` of a stack, which default to the dir name)

- Each copy is isolated from the others (runs on a different network)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Checking stack status

We have `ps`, `docker ps`, and similarly, `docker-compose ps`:

```bash
$ docker-compose ps
Name                      Command             State           Ports          
----------------------------------------------------------------------------
trainingwheels_redis_1   /entrypoint.sh red   Up      6379/tcp               
trainingwheels_www_1     python counter.py    Up      0.0.0.0:8000->5000/tcp 
```

Shows the status of all the containers of our stack.

Doesn't show the other containers.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Cleaning up (1)

If you have started your application in the background with Compose and
want to stop it easily, you can use the `kill` command:

```bash
$ docker-compose kill
```

Likewise, `docker-compose rm` will let you remove containers (after confirmation):

```bash
$ docker-compose rm
Going to remove trainingwheels_redis_1, trainingwheels_www_1
Are you sure? [yN] y
Removing trainingwheels_redis_1...
Removing trainingwheels_www_1...
```

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Cleaning up (2)

Alternatively, `docker-compose down` will stop and remove containers.

It will also remove other resources, like networks that were created for the application.

```bash
$ docker-compose down
Stopping trainingwheels_www_1 ... done
Stopping trainingwheels_redis_1 ... done
Removing trainingwheels_www_1 ... done
Removing trainingwheels_redis_1 ... done
```

Use `docker-compose down -v` to remove everything including volumes.

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Special handling of volumes

- When an image gets updated, Compose automatically creates a new container

- The data in the old container is lost...

- ...Except if the container is using a *volume*

- Compose will then re-attach that volume to the new container

  (and data is then retained across database upgrades)

- All good database images use volumes

  (e.g. all official images)

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Gotchas with volumes

- Unfortunately, Docker volumes don't have labels or metadata

- Compose tracks volumes thanks to their associated container

- If the container is deleted, the volume gets orphaned

- Example: `docker-compose down && docker-compose up`

  - the old volume still exists, detached from its container

  - a new volume gets created

- `docker-compose down -v`/`--volumes` deletes volumes

  (but **not** `docker-compose down && docker-compose down -v`!)
 
.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Managing volumes explicitly

Option 1: *named volumes*

```yaml
services:
  app:
    volumes:
    - data:/some/path
volumes:
  data:
```

- Volume will be named `<project>_data`

- It won't be orphaned with `docker-compose down`

- It will correctly be removed with `docker-compose down -v`

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Managing volumes explicitly

Option 2: *relative paths*

```yaml
services:
  app:
    volumes:
    - ./data:/some/path
```

- Makes it easy to colocate the app and its data

  (for migration, backups, disk usage accounting...)

- Won't be removed by `docker-compose down -v`

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Managing complex stacks

- Compose provides multiple features to manage complex stacks

  (with many containers)

- `-f`/`--file`/`$COMPOSE_FILE` can be a list of Compose files

  (separated by `:` and merged together)

- Services can be assigned to one or more *profiles*

- `--profile`/`$COMPOSE_PROFILE` can be a list of comma-separated profiles

  (see [Using service profiles][profiles] in the Compose documentation)

- These variables can be set in `.env`

[profiles]: https://docs.docker.com/compose/profiles/

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

## Dependencies

- A service can have a `depends_on` section

  (listing one or more other services)

- This is used when bringing up individual services

  (e.g. `docker-compose up blah` or `docker-compose run foo`)

‚ö†Ô∏è It doesn't make a service "wait" for another one to be up!

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

class: extra-details

## A bit of history and trivia

- Compose was initially named "Fig"

- Compose is one of the only components of Docker written in Python

  (almost everything else is in Go)

- In 2020, Docker introduced "Compose CLI":

  - `docker compose` command to deploy Compose stacks to some clouds

  - progressively getting feature parity with `docker-compose`

  - also provides numerous improvements (e.g. leverages BuildKit by default)

???

:EN:- Using compose to describe an environment
:EN:- Connecting services together with a *Compose file*

:FR:- Utiliser Compose pour d√©crire son environnement
:FR:- √âcrire un *Compose file* pour connecter les services entre eux

.debug[[containers/Compose_For_Dev_Stacks.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Compose_For_Dev_Stacks.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/lots-of-containers.jpg)]

---

name: toc-exercise--writing-a-compose-file
class: title

 Exercise ‚Äî writing a Compose file

.nav[
[Previous part](#toc-compose-for-development-stacks)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-exercise--writing-a-compose-file)
]

.debug[(automatically generated title slide)]

---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/plastic-containers.JPG)]

---

name: toc-exercise--writing-a-compose-file
class: title

 Exercise ‚Äî writing a Compose file

.nav[
[Previous part](#toc-compose-for-development-stacks)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-exercise--writing-a-compose-file)
]

.debug[(automatically generated title slide)]

---
# Exercise ‚Äî writing a Compose file

Let's write a Compose file for the wordsmith app!

The code is at: https://github.com/jpetazzo/wordsmith

.debug[[containers/Exercise_Composefile.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Composefile.md)]
---
# Exercise ‚Äî writing a Compose file

Let's write a Compose file for the wordsmith app!

The code is at: https://github.com/jpetazzo/wordsmith

.debug[[containers/Exercise_Composefile.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/Exercise_Composefile.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-1.jpg)]

---

name: toc-tp--deploying-a-sample-application
class: title

 TP : Deploying a sample application

.nav[
[Previous part](#toc-exercise--writing-a-compose-file)
|
[Back to table of contents](#toc-part-3)
|
[Next part](#toc-kubernetes-concepts)
]

.debug[(automatically generated title slide)]

---
# TP : Deploying a sample application

- We will connect to our new Linux lab VM

- We will clone the TP repository

.lab[

- Clone the repository on your VM:
  ```bash
  git clone https://github.com/GuillaumeMorini/TP-Docker
  ```

]

- This repository has the source code but no Dockerfile or docker-compose.yml

.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

## What's this application?

--

- It is a DockerCoin miner! üí∞üê≥üì¶üö¢

--

- No, you can't buy coffee with DockerCoins

--

- How DockerCoins works:

  - generate a few random bytes

  - hash these bytes

  - increment a counter (to keep track of speed)

  - repeat forever!

--

- DockerCoins is *not* a cryptocurrency

  (the only common points are "randomness", "hashing", and "coins" in the name)

.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

## DockerCoins in the microservices era

- DockerCoins is made of 5 services:

  - `rng` = web service generating random bytes

  - `hasher` = web service computing hash of POSTed data

  - `worker` = background process calling `rng` and `hasher`

  - `webui` = web interface to watch progress

  - `redis` = data store (holds a counter updated by `worker`)

- These 5 services should be visible in your application's Compose file at the end of the lab.

.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

## How DockerCoins works

- `worker` invokes web service `rng` to generate random bytes

- `worker` invokes web service `hasher` to hash these bytes

- `worker` does this in an infinite loop

- every second, `worker` updates `redis` to indicate how many loops were done

- `webui` queries `redis`, and computes and exposes "hashing speed" in our browser

*(See diagram on next slide!)*

.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

class: pic

![Diagram showing the 5 containers of the applications](images/dockercoins-diagram.png)

.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

## Service discovery in container-land

How does each service find out the address of the other ones?

--

- We do not hard-code IP addresses in the code

- We do not hard-code FQDNs in the code, either

- We just connect to a service name, and container-magic does the rest

  (And by container-magic, we mean "a crafty, dynamic, embedded DNS server")

.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

## Example in `worker/worker.py`

```python
redis = Redis("`redis`")


def get_random_bytes():
    r = requests.get("http://`rng`/32")
    return r.content


def hash_bytes(data):
    r = requests.post("http://`hasher`/",
                      data=data,
                      headers={"Content-Type": "application/octet-stream"})
```

(Feel free to check the full source code of the worker!)

.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

## Connecting to the web UI

- The `webui` container exposes a web dashboard; let's view it

.lab[

- Check the port allocated to the web UI:
  ```bash
  docker compose ps
  ```

- Open that in a web browser (after doing the SSH port forward)

]

A drawing area should show up, and after a few seconds, a blue
graph will appear.

.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

## Bonus points

- The observed performance of dockercoins should be around 5 coins per second

- You will get bonus points if you explain how you succeed to go above 5 coins per second

- Even more bonus points if you can go above 20 coins per second

.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

class: title, pic

## Up to you


![The floor is yours](images/floor_is_yours.jpg)
.debug[[containers/dockercoins.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/containers/dockercoins.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/train-of-containers-2.jpg)]

---

name: toc-kubernetes-concepts
class: title

 Kubernetes concepts

.nav[
[Previous part](#toc-tp--deploying-a-sample-application)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-declarative-vs-imperative)
]

.debug[(automatically generated title slide)]

---
# Kubernetes concepts

- Kubernetes is a container management system

- It runs and manages containerized applications on a cluster

--

- What does that really mean?

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

## What can we do with Kubernetes?

- Let's imagine that we have a 3-tier e-commerce app:

  - web frontend

  - API backend

  - database (that we will keep out of Kubernetes for now)

- We have built images for our frontend and backend components

  (e.g. with Dockerfiles and `docker build`)

- We are running them successfully with a local environment

  (e.g. with Docker Compose)

- Let's see how we would deploy our app on Kubernetes!

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---


## Basic things we can ask Kubernetes to do

--

- Start 5 containers using image `atseashop/api:v1.3`

--

- Place an internal load balancer in front of these containers

--

- Start 10 containers using image `atseashop/webfront:v1.3`

--

- Place a public load balancer in front of these containers

--

- It's Black Friday (or Christmas), traffic spikes, grow our cluster and add containers

--

- New release! Replace my containers with the new image `atseashop/webfront:v1.4`

--

- Keep processing requests during the upgrade; update my containers one at a time

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

## Other things that Kubernetes can do for us

- Autoscaling

  (straightforward on CPU; more complex on other metrics)

- Resource management and scheduling

  (reserve CPU/RAM for containers; placement constraints)

- Advanced rollout patterns

  (blue/green deployment, canary deployment)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

## More things that Kubernetes can do for us

- Batch jobs

  (one-off; parallel; also cron-style periodic execution)

- Fine-grained access control

  (defining *what* can be done by *whom* on *which* resources)

- Stateful services

  (databases, message queues, etc.)

- Automating complex tasks with *operators*

  (e.g. database replication, failover, etc.)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

## Kubernetes architecture

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: pic

![that one is more like the real thing](images/k8s-arch2.png)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

## Kubernetes architecture: the nodes

- The nodes executing our containers run a collection of services:

  - a container Engine (typically Docker)

  - kubelet (the "node agent")

  - kube-proxy (a necessary but not sufficient network component)

- Nodes were formerly called "minions"

  (You might see that word in older articles or documentation)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

## Kubernetes architecture: the control plane

- The Kubernetes logic (its "brains") is a collection of services:

  - the API server (our point of entry to everything!)

  - core services like the scheduler and controller manager

  - `etcd` (a highly available key/value store; the "database" of Kubernetes)

- Together, these services form the control plane of our cluster

- The control plane is also called the "master"

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: pic

![One of the best Kubernetes architecture diagrams available](images/k8s-arch4-thanks-luxas.png)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: extra-details

## Running the control plane on special nodes

- It is common to reserve a dedicated node for the control plane

  (Except for single-node development clusters, like when using minikube)

- This node is then called a "master"

  (Yes, this is ambiguous: is the "master" a node, or the whole control plane?)

- Normal applications are restricted from running on this node

  (By using a mechanism called ["taints"](https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/))

- When high availability is required, each service of the control plane must be resilient

- The control plane is then replicated on multiple nodes

  (This is sometimes called a "multi-master" setup)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: extra-details

## Running the control plane outside containers

- The services of the control plane can run in or out of containers

- For instance: since `etcd` is a critical service, some people
  deploy it directly on a dedicated cluster (without containers)

  (This is illustrated on the first "super complicated" schema)

- In some hosted Kubernetes offerings (e.g. AKS, GKE, EKS), the control plane is invisible

  (We only "see" a Kubernetes API endpoint)

- In that case, there is no "master node"

*For this reason, it is more accurate to say "control plane" rather than "master."*

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: pic
![](images/control-planes/single-node-dev.svg)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: pic
![](images/control-planes/managed-kubernetes.svg)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: pic
![](images/control-planes/single-control-and-workers.svg)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: pic
![](images/control-planes/stacked-control-plane.svg)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: extra-details

## How many nodes should a cluster have?

- There is no particular constraint

  (no need to have an odd number of nodes for quorum)

- A cluster can have zero node

  (but then it won't be able to start any pods)

- For testing and development, having a single node is fine

- For production, make sure that you have extra capacity

  (so that your workload still fits if you lose a node or a group of nodes)

- Kubernetes is tested with [up to 5000 nodes](https://kubernetes.io/docs/setup/best-practices/cluster-large/)

  (however, running a cluster of that size requires a lot of tuning)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: extra-details

## Do we need to run Docker at all?

No!

--

- The Docker Engine used to be the default option to run containers with Kubernetes

- Support for Docker (specifically: dockershim) was removed in Kubernetes 1.24

- We can leverage other pluggable runtimes through the *Container Runtime Interface*

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: extra-details

## Some runtimes available through CRI

- [containerd](https://github.com/containerd/containerd/blob/master/README.md)

  - maintained by Docker, IBM, and community
  - used by Docker Engine, microk8s, k3s, GKE; also standalone
  - comes with its own CLI, `ctr`

- [CRI-O](https://github.com/cri-o/cri-o/blob/master/README.md):

  - maintained by Red Hat, SUSE, and community
  - used by OpenShift and Kubic
  - designed specifically as a minimal runtime for Kubernetes

- [And more](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: extra-details

## Do we need to run Docker at all?

- On our Kubernetes clusters:

  *Not anymore*

- On our development environments, CI pipelines ... :

  *Yes, almost certainly*

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

## Interacting with Kubernetes

- We will interact with our Kubernetes cluster through the Kubernetes API

- The Kubernetes API is (mostly) RESTful

- It allows us to create, read, update, delete *resources*

- A few common resource types are:

  - node (a machine ‚Äî physical or virtual ‚Äî in our cluster)

  - pod (group of containers running together on a node)

  - service (stable network endpoint to connect to one or multiple containers)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: pic

![Node, pod, container](images/k8s-arch3-thanks-weave.png)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

## Scaling

- How would we scale the pod shown on the previous slide?

- **Do** create additional pods

  - each pod can be on a different node

  - each pod will have its own IP address

- **Do not** add more NGINX containers in the pod

  - all the NGINX containers would be on the same node

  - they would all have the same IP address
    <br/>(resulting in `Address alreading in use` errors)

.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

## Together or separate

- Should we put e.g. a web application server and a cache together?
  <br/>
  ("cache" being something like e.g. Memcached or Redis)

- Putting them **in the same pod** means:

  - they have to be scaled together

  - they can communicate very efficiently over `localhost`

- Putting them **in different pods** means:

  - they can be scaled separately

  - they must communicate over remote IP addresses
    <br/>(incurring more latency, lower performance)

- Both scenarios can make sense, depending on our goals


.debug[[k8s/concepts-k8s.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/concepts-k8s.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/two-containers-on-a-truck.jpg)]

---

name: toc-declarative-vs-imperative
class: title

 Declarative vs imperative

.nav[
[Previous part](#toc-kubernetes-concepts)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-setting-up-kubernetes)
]

.debug[(automatically generated title slide)]

---
# Declarative vs imperative

- Our container orchestrator puts a very strong emphasis on being *declarative*

- Declarative:

  *I would like a cup of tea.*

- Imperative:

  *Boil some water. Pour it in a teapot. Add tea leaves. Steep for a while. Serve in a cup.*

--

- Declarative seems simpler at first ... 

--

- ... As long as you know how to brew tea

.debug[[shared/declarative.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/declarative.md)]
---

## Declarative vs imperative

- What declarative would really be:

  *I want a cup of tea, obtained by pouring an infusion¬π of tea leaves in a cup.*

--

  *¬πAn infusion is obtained by letting the object steep a few minutes in hot¬≤ water.*

--

  *¬≤Hot liquid is obtained by pouring it in an appropriate container¬≥ and setting it on a stove.*

--

  *¬≥Ah, finally, containers! Something we know about. Let's get to work, shall we?*

--

.footnote[Did you know there was an [ISO standard](https://en.wikipedia.org/wiki/ISO_3103)
specifying how to brew tea?]

.debug[[shared/declarative.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/declarative.md)]
---

## Declarative vs imperative

- Imperative systems:

  - simpler

  - if a task is interrupted, we have to restart from scratch

- Declarative systems:

  - if a task is interrupted (or if we show up to the party half-way through),
    we can figure out what's missing and do only what's necessary

  - we need to be able to *observe* the system

  - ... and compute a "diff" between *what we have* and *what we want*

.debug[[shared/declarative.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/shared/declarative.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/wall-of-containers.jpeg)]

---

name: toc-setting-up-kubernetes
class: title

 Setting up Kubernetes

.nav[
[Previous part](#toc-declarative-vs-imperative)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-first-contact-with-kubectl)
]

.debug[(automatically generated title slide)]

---
# Setting up Kubernetes

- Kubernetes is made of many components that require careful configuration

- Secure operation typically requires TLS certificates and a local CA

  (certificate authority)

- Setting up everything manually is possible, but rarely done

  (except for learning purposes)

- Let's do a quick overview of available options!

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Local development

- Are you writing code that will eventually run on Kubernetes?

- Then it's a good idea to have a development cluster!

- Instead of shipping containers images, we can test them on Kubernetes

- Extremely useful when authoring or testing Kubernetes-specific objects

  (ConfigMaps, Secrets, StatefulSets, Jobs, RBAC, etc.)

- Extremely convenient to quickly test/check what a particular thing looks like

  (e.g. what are the fields a Deployment spec?)

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## One-node clusters

- It's perfectly fine to work with a cluster that has only one node

- It simplifies a lot of things:

  - pod networking doesn't even need CNI plugins, overlay networks, etc.

  - these clusters can be fully contained (no pun intended) in an easy-to-ship VM or container image

  - some of the security aspects may be simplified (different threat model)

  - images can be built directly on the node (we don't need to ship them with a registry)

- Examples: Docker Desktop, k3d, KinD, MicroK8s, Minikube

  (some of these also support clusters with multiple nodes)

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Managed clusters ("Turnkey Solutions")

- Many cloud providers and hosting providers offer "managed Kubernetes"

- The deployment and maintenance of the *control plane* is entirely managed by the provider

  (ideally, clusters can be spun up automatically through an API, CLI, or web interface)

- Given the complexity of Kubernetes, this approach is *strongly recommended*

  (at least for your first production clusters)

- After working for a while with Kubernetes, you will be better equipped to decide:

  - whether to operate it yourself or use a managed offering

  - which offering or which distribution works best for you and your needs

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Node management

- Most "Turnkey Solutions" offer fully managed control planes

  (including control plane upgrades, sometimes done automatically)

- However, with most providers, we still need to take care of *nodes*

  (provisioning, upgrading, scaling the nodes)

- Example with Amazon EKS ["managed node groups"](https://docs.aws.amazon.com/eks/latest/userguide/managed-node-groups.html):

  *...when bugs or issues are reported [...] you're responsible for deploying these patched AMI versions to your managed node groups.*

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Managed clusters differences

- Most providers let you pick which Kubernetes version you want

  - some providers offer up-to-date versions

  - others lag significantly (sometimes by 2 or 3 minor versions)

- Some providers offer multiple networking or storage options

- Others will only support one, tied to their infrastructure

  (changing that is in theory possible, but might be complex or unsupported)

- Some providers let you configure or customize the control plane

  (generally through Kubernetes "feature gates")

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Choosing a provider

- Pricing models differ from one provider to another

  - nodes are generally charged at their usual price

  - control plane may be free or incur a small nominal fee

- Beyond pricing, there are *huge* differences in features between providers

- The "major" providers are not always the best ones!

- See [this page](https://kubernetes.io/docs/setup/production-environment/turnkey-solutions/) for a list of available providers

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Kubernetes distributions and installers

- If you want to run Kubernetes yourselves, there are many options

  (free, commercial, proprietary, open source ...)

- Some of them are installers, while some are complete platforms

- Some of them leverage other well-known deployment tools

  (like Puppet, Terraform ...)

- There are too many options to list them all

  (check [this page](https://kubernetes.io/partners/#conformance) for an overview!)

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## kubeadm

- kubeadm is a tool part of Kubernetes to facilitate cluster setup

- Many other installers and distributions use it (but not all of them)

- It can also be used by itself

- Excellent starting point to install Kubernetes on your own machines

  (virtual, physical, it doesn't matter)

- It even supports highly available control planes, or "multi-master"

  (this is more complex, though, because it introduces the need for an API load balancer)

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Manual setup

- The resources below are mainly for educational purposes!

- [Kubernetes The Hard Way](https://github.com/kelseyhightower/kubernetes-the-hard-way) by Kelsey Hightower

  *step by step guide to install Kubernetes on GCP, with certificates, HA...*

- [Deep Dive into Kubernetes Internals for Builders and Operators](https://www.youtube.com/watch?v=3KtEAa7_duA)

  *conference talk setting up a simplified Kubernetes cluster - no security or HA*

- üá´üá∑[D√©mystifions les composants internes de Kubernetes](https://www.youtube.com/watch?v=OCMNA0dSAzc)

  *improved version of the previous one, with certs and recent k8s versions*

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## About our training clusters

- How will we set up these Kubernetes clusters that we will use?

--

- We will use `kubeadm` on our VMs running Debian

    1. We already install Docker

    2. We will need to install Kubernetes packages

    3. Run `kubeadm init` on the first node (it deploys the control plane on that node)

    4. Set up  Calico (the overlay network) with two `kubectl apply` commands

    5. Run `kubeadm join` on the other nodes (with the token produced by `kubeadm init`)

    6. Copy the configuration file generated by `kubeadm init`

- More detailed instructions to follow

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## `kubeadm` "drawbacks"

- Doesn't set up Docker or any other container engine

  (this is by design, to give us choice)

- Doesn't set up the overlay network

  (this is also by design, for the same reasons)

- HA control plane requires [some extra steps](https://kubernetes.io/docs/setup/independent/high-availability/)

- Note that HA control plane also requires setting up a specific API load balancer

  (which is beyond the scope of kubeadm)

???

:EN:- Various ways to install Kubernetes
:FR:- Survol des techniques d'installation de Kubernetes

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Lab instructions - preps 1/8

.lab[
On both VMs, edit as root the file `/etc/containerd/config.toml`
He should look like this:
```bash
#disabled_plugins = ["cri"]
version = 2
[plugins]
  [plugins."io.containerd.grpc.v1.cri"]
   [plugins."io.containerd.grpc.v1.cri".containerd]
      [plugins."io.containerd.grpc.v1.cri".containerd.runtimes]
        [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
          runtime_type = "io.containerd.runc.v2"
          [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc.options]
            SystemdCgroup = true
```
Don't forget to restart containerd with the command `sudo systemctl restart containerd`
]

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Lab instructions - preps 2/8

.lab[

On both VMs

```bash
sudo swapoff -a
```

]

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Lab instructions - master 3/8

.lab2[

On both VMs
```bash
sudo apt-get update
sudo apt-get install -y apt-transport-https ca-certificates curl gpg

curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.32/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.32/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list

sudo apt-get update
sudo apt-get install -y kubelet kubeadm kubectl
sudo apt-mark hold kubelet kubeadm kubectl
```

On the first VM
You can then init the Kubernetes cluster:
```bash
kubeadm init --pod-network-cidr=192.168.0.0/16
```

]

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Lab instructions - output master 4/8

.lab[

You should have a message similar to this one

```bash

Your Kubernetes control-plane has initialized successfully!

....

Then you can join any number of worker nodes by running this on each as root:

kubeadm join 172.16.25.4:6443 --token 43fmlr.ng2dscnjrjsxom45 
	--discovery-token-ca-cert-hash sha256:3545364e549f 

```
Copy the last 2 lines for later

]

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Lab instructions - check master 5/8

.lab[


Check everything is working well, you should have
```bash
$ mkdir -p ~/.kube
$ sudo cp /etc/kubernetes/admin.conf ~/.kube/config
$ sudo chmod 0644 ~/.kube/config
$ kubectl get nodes
NAME             STATUS     ROLES           AGE   VERSION
1224bdebstd002   NotReady   control-plane   13s   v1.32.2
$ 
```

Still on the first VM, allow workload to run on the control plane
```bash
kubectl taint nodes --all node-role.kubernetes.io/control-plane-
```

]

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Lab instructions - add a node 6/8

.lab[

On the second VM, reuse the 2 lines you copied previously
```bash
kubeadm join xxxxxx --token xxxx --discovery-token-ca-cert-hash xxxx
```


]

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Lab instructions - install CNI 7/8

.lab3[



Finally, on the first VM, install the CNI
```bash
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.29.2/manifests/tigera-operator.yaml
kubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.29.2/manifests/custom-resources.yaml
```
]

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

## Lab instructions - check CNI 8/8

.lab3[

Check if everything works well, after few minutes
```bash
$ kubectl get pods -A
NAMESPACE          NAME                                       READY   STATUS    RESTARTS   AGE
calico-apiserver   calico-apiserver-9657959cd-rztkj           1/1     Running   0          23m
calico-apiserver   calico-apiserver-9657959cd-zb7wx           1/1     Running   0          23m
calico-system      calico-kube-controllers-79655dc7cf-8zxcl   1/1     Running   0          23m
calico-system      calico-node-7q9bm                          1/1     Running   0          23m
calico-system      calico-node-jhbwp                          1/1     Running   0          23m
calico-system      calico-typha-cbc6667cf-mv7kr               1/1     Running   0          23m
calico-system      csi-node-driver-fnq5r                      2/2     Running   0          23m
calico-system      csi-node-driver-k5sxj                      2/2     Running   0          23m
kube-system        coredns-668d6bf9bc-2kfhq                   1/1     Running   0          32m
kube-system        coredns-668d6bf9bc-4zsjx                   1/1     Running   0          32m
kube-system        etcd-1224bdebstd002                        1/1     Running   23         32m
kube-system        kube-apiserver-1224bdebstd002              1/1     Running   27         32m
kube-system        kube-controller-manager-1224bdebstd002     1/1     Running   0          32m
kube-system        kube-proxy-5w926                           1/1     Running   0          32m
kube-system        kube-proxy-fh5l8                           1/1     Running   0          31m
kube-system        kube-scheduler-1224bdebstd002              1/1     Running   26         32m
tigera-operator    tigera-operator-ccfc44587-fnzb4            1/1     Running   0          23m
$ 
```

]

.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---

class: pic
![](images/congrats.gif)


.debug[[k8s/setup-overview.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/setup-overview.md)]
---
## Declarative vs imperative in Kubernetes

- With Kubernetes, we cannot say: "run this container"

- All we can do is write a *spec* and push it to the API server

  (by creating a resource like e.g. a Pod or a Deployment)

- The API server will validate that spec (and reject it if it's invalid)

- Then it will store it in etcd

- A *controller* will "notice" that spec and act upon it

.debug[[k8s/declarative.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/declarative.md)]
---

## Reconciling state

- Watch for the `spec` fields in the YAML files later!

- The *spec* describes *how we want the thing to be*

- Kubernetes will *reconcile* the current state with the spec
  <br/>(technically, this is done by a number of *controllers*)

- When we want to change some resource, we update the *spec*

- Kubernetes will then *converge* that resource

???

:EN:- Declarative vs imperative models
:FR:- Mod√®les d√©claratifs et imp√©ratifs

.debug[[k8s/declarative.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/declarative.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/catene-de-conteneurs.jpg)]

---

name: toc-first-contact-with-kubectl
class: title

 First contact with `kubectl`

.nav[
[Previous part](#toc-setting-up-kubernetes)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-running-our-first-containers-on-kubernetes)
]

.debug[(automatically generated title slide)]

---
# First contact with `kubectl`

- `kubectl` is (almost) the only tool we'll need to talk to Kubernetes

- It is a rich CLI tool around the Kubernetes API

  (Everything you can do with `kubectl`, you can do directly with the API)

- On our machines, there is a `~/.kube/config` file with:

  - the Kubernetes API address

  - the path to our TLS certificates used to authenticate

- You can also use the `--kubeconfig` flag to pass a config file

- Or directly `--server`, `--user`, etc.

- `kubectl` can be pronounced "Cube C T L", "Cube cuttle", "Cube cuddle"...

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

class: extra-details

## `kubectl` is the new SSH

- We often start managing servers with SSH

  (installing packages, troubleshooting ...)

- At scale, it becomes tedious, repetitive, error-prone

- Instead, we use config management, central logging, etc.

- In many cases, we still need SSH:

  - as the underlying access method (e.g. Ansible)

  - to debug tricky scenarios

  - to inspect and poke at things

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

class: extra-details

## The parallel with `kubectl`

- We often start managing Kubernetes clusters with `kubectl`

  (deploying applications, troubleshooting ...)

- At scale (with many applications or clusters), it becomes tedious, repetitive, error-prone

- Instead, we use automated pipelines, observability tooling, etc.

- In many cases, we still need `kubectl`:

  - to debug tricky scenarios

  - to inspect and poke at things

- The Kubernetes API is always the underlying access method

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## `kubectl get`

- Let's look at our `Node` resources with `kubectl get`!

.lab[

- Look at the composition of our cluster:
  ```bash
  kubectl get node
  ```

- These commands are equivalent:
  ```bash
  kubectl get no
  kubectl get node
  kubectl get nodes
  ```

]

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Obtaining machine-readable output

- `kubectl get` can output JSON, YAML, or be directly formatted

.lab[

- Give us more info about the nodes:
  ```bash
  kubectl get nodes -o wide
  ```

- Let's have some YAML:
  ```bash
  kubectl get no -o yaml
  ```
  See that `kind: List` at the end? It's the type of our result!

]

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## (Ab)using `kubectl` and `jq`

- It's super easy to build custom reports

.lab[

- Show the capacity of all our nodes as a stream of JSON objects:
  ```bash
    kubectl get nodes -o json |
            jq ".items[] | {name:.metadata.name} + .status.capacity"
  ```

]

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

class: extra-details

## Exploring types and definitions

- We can list all available resource types by running `kubectl api-resources`
  <br/>
  (In Kubernetes 1.10 and prior, this command used to be `kubectl get`)

- We can view the definition for a resource type with:
  ```bash
  kubectl explain type
  ```

- We can view the definition of a field in a resource, for instance:
  ```bash
  kubectl explain node.spec
  ```

- Or get the full definition of all fields and sub-fields:
  ```bash
  kubectl explain node --recursive
  ```

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

class: extra-details

## Introspection vs. documentation

- We can access the same information by reading the [API documentation](https://kubernetes.io/docs/reference/#api-reference)

- The API documentation is usually easier to read, but:

  - it won't show custom types (like Custom Resource Definitions)

  - we need to make sure that we look at the correct version

- `kubectl api-resources` and `kubectl explain` perform *introspection*

  (they communicate with the API server and obtain the exact type definitions)

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Type names

- The most common resource names have three forms:

  - singular (e.g. `node`, `service`, `deployment`)

  - plural (e.g. `nodes`, `services`, `deployments`)

  - short (e.g. `no`, `svc`, `deploy`)

- Some resources do not have a short name

- `Endpoints` only have a plural form

  (because even a single `Endpoints` resource is actually a list of endpoints)

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Viewing details

- We can use `kubectl get -o yaml` to see all available details

- However, YAML output is often simultaneously too much and not enough

- For instance, `kubectl get node node1 -o yaml` is:

  - too much information (e.g.: list of images available on this node)

  - not enough information (e.g.: doesn't show pods running on this node)

  - difficult to read for a human operator

- For a comprehensive overview, we can use `kubectl describe` instead

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## `kubectl describe`

- `kubectl describe` needs a resource type and (optionally) a resource name

- It is possible to provide a resource name *prefix*

  (all matching objects will be displayed)

- `kubectl describe` will retrieve some extra information about the resource

.lab[

- Look at the information available for `node1` with one of the following commands:
  ```bash
  kubectl describe node/node1
  kubectl describe node node1
  ```

]

(We should notice a bunch of control plane pods.)

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Listing running containers

- Containers are manipulated through *pods*

- A pod is a group of containers:

 - running together (on the same node)

 - sharing resources (RAM, CPU; but also network, volumes)

.lab[

- List pods on our cluster:
  ```bash
  kubectl get pods
  ```

]

--

*Where are the pods that we saw just a moment earlier?!?*

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Namespaces

- Namespaces allow us to segregate resources

.lab[

- List the namespaces on our cluster with one of these commands:
  ```bash
  kubectl get namespaces
  kubectl get namespace
  kubectl get ns
  ```

]

--

*You know what ... This `kube-system` thing looks suspicious.*

*In fact, I'm pretty sure it showed up earlier, when we did:*

`kubectl describe node node1`

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Accessing namespaces

- By default, `kubectl` uses the `default` namespace

- We can see resources in all namespaces with `--all-namespaces`

.lab[

- List the pods in all namespaces:
  ```bash
  kubectl get pods --all-namespaces
  ```

- Since Kubernetes 1.14, we can also use `-A` as a shorter version:
  ```bash
  kubectl get pods -A
  ```

]

*Here are our system pods!*

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## What are all these control plane pods?

- `etcd` is our etcd server

- `kube-apiserver` is the API server

- `kube-controller-manager` and `kube-scheduler` are other control plane components

- `coredns` provides DNS-based service discovery ([replacing kube-dns as of 1.11](https://kubernetes.io/blog/2018/07/10/coredns-ga-for-kubernetes-cluster-dns/))

- `kube-proxy` is the (per-node) component managing port mappings and such

- `weave` is the (per-node) component managing the network overlay

- the `READY` column indicates the number of containers in each pod

  (1 for most pods, but `weave` has 2, for instance)

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Scoping another namespace

- We can also look at a different namespace (other than `default`)

.lab[

- List only the pods in the `kube-system` namespace:
  ```bash
  kubectl get pods --namespace=kube-system
  kubectl get pods -n kube-system
  ```

]

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Namespaces and other `kubectl` commands

- We can use `-n`/`--namespace` with almost every `kubectl` command

- Example:

  - `kubectl create --namespace=X` to create something in namespace X

- We can use `-A`/`--all-namespaces` with most commands that manipulate multiple objects

- Examples:

  - `kubectl delete` can delete resources across multiple namespaces

  - `kubectl label` can add/remove/update labels across multiple namespaces

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

class: extra-details

## What about `kube-public`?

.lab[

- List the pods in the `kube-public` namespace:
  ```bash
  kubectl -n kube-public get pods
  ```

]

Nothing!

`kube-public` is created by kubeadm & [used for security bootstrapping](https://kubernetes.io/blog/2017/01/stronger-foundation-for-creating-and-managing-kubernetes-clusters).

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

class: extra-details

## Exploring `kube-public`

- The only interesting object in `kube-public` is a ConfigMap named `cluster-info`

.lab[

- List ConfigMap objects:
  ```bash
  kubectl -n kube-public get configmaps
  ```

- Inspect `cluster-info`:
  ```bash
  kubectl -n kube-public get configmap cluster-info -o yaml
  ```

]

Note the `selfLink` URI: `/api/v1/namespaces/kube-public/configmaps/cluster-info`

We can use that!

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

class: extra-details

## Accessing `cluster-info`

- Earlier, when trying to access the API server, we got a `Forbidden` message

- But `cluster-info` is readable by everyone (even without authentication)

.lab[

- Retrieve `cluster-info`:
  ```bash
  curl -k https://10.96.0.1/api/v1/namespaces/kube-public/configmaps/cluster-info
  ```

]

- We were able to access `cluster-info` (without auth)

- It contains a `kubeconfig` file

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

class: extra-details

## Retrieving `kubeconfig`

- We can easily extract the `kubeconfig` file from this ConfigMap

.lab[

- Display the content of `kubeconfig`:
  ```bash
    curl -sk https://10.96.0.1/api/v1/namespaces/kube-public/configmaps/cluster-info \
         | jq -r .data.kubeconfig
  ```

]

- This file holds the canonical address of the API server, and the public key of the CA

- This file *does not* hold client keys or tokens

- This is not sensitive information, but allows us to establish trust

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Services

- A *service* is a stable endpoint to connect to "something"

  (In the initial proposal, they were called "portals")

.lab[

- List the services on our cluster with one of these commands:
  ```bash
  kubectl get services
  kubectl get svc
  ```

]

--

There is already one service on our cluster: the Kubernetes API itself.

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## ClusterIP services

- A `ClusterIP` service is internal, available from the cluster only

- This is useful for introspection from within containers

.lab[

- Try to connect to the API:
  ```bash
  curl -k https://`10.96.0.1`
  ```

  - `-k` is used to skip certificate verification

  - Make sure to replace 10.96.0.1 with the CLUSTER-IP shown by `kubectl get svc`

]

The command above should either time out, or show an authentication error. Why?

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Time out

- Connections to ClusterIP services only work *from within the cluster*

- If we are outside the cluster, the `curl` command will probably time out

  (Because the IP address, e.g. 10.96.0.1, isn't routed properly outside the cluster)

- This is the case with most "real" Kubernetes clusters

- To try the connection from within the cluster, we can use [shpod](https://github.com/jpetazzo/shpod)

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Authentication error

This is what we should see when connecting from within the cluster:
```json
$ curl -k https://10.96.0.1
{
  "kind": "Status",
  "apiVersion": "v1",
  "metadata": {

  },
  "status": "Failure",
  "message": "forbidden: User \"system:anonymous\" cannot get path \"/\"",
  "reason": "Forbidden",
  "details": {

  },
  "code": 403
}
```

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## Explanations

- We can see `kind`, `apiVersion`, `metadata`

- These are typical of a Kubernetes API reply

- Because we *are* talking to the Kubernetes API

- The Kubernetes API tells us "Forbidden"

  (because it requires authentication)

- The Kubernetes API is reachable from within the cluster

  (many apps integrating with Kubernetes will use this)

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

## DNS integration

- Each service also gets a DNS record

- The Kubernetes DNS resolver is available *from within pods*

  (and sometimes, from within nodes, depending on configuration)

- Code running in pods can connect to services using their name

  (e.g. https://kubernetes/...)

???

:EN:- Getting started with kubectl
:FR:- Se familiariser avec kubectl

.debug[[k8s/kubectlget.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlget.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/Container-Ship-Freighter-Navigation-Elbe-Romance-1782991.jpg)]

---

name: toc-running-our-first-containers-on-kubernetes
class: title

 Running our first containers on Kubernetes

.nav[
[Previous part](#toc-first-contact-with-kubectl)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-revisiting-kubectl-logs)
]

.debug[(automatically generated title slide)]

---
# Running our first containers on Kubernetes

- First things first: we cannot run a container

--

- We are going to run a pod, and in that pod there will be a single container

--

- In that container in the pod, we are going to run a simple `ping` command

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

class: extra-details

## If you're running Kubernetes 1.17 (or older)...

- This material assumes that you're running a recent version of Kubernetes

  (at least 1.19) <!-- ##VERSION## -->

- You can check your version number with `kubectl version`

  (look at the server part)

- In Kubernetes 1.17 and older, `kubectl run` creates a Deployment

- If you're running such an old version:

  - it's obsolete and no longer maintained

  - Kubernetes 1.17 is [EOL since January 2021][nonactive]

  - **upgrade NOW!**

[nonactive]: https://kubernetes.io/releases/patch-releases/#non-active-branch-history

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Starting a simple pod with `kubectl run`

- `kubectl run` is convenient to start a single pod

- We need to specify at least a *name* and the image we want to use

- Optionally, we can specify the command to run in the pod

.lab[

- Let's ping the address of `localhost`, the loopback interface:
  ```bash
  kubectl run pingpong --image alpine ping 127.0.0.1
  ```

<!-- ```hide kubectl wait pod --selector=run=pingpong --for condition=ready``` -->

]

The output tells us that a Pod was created:
```
pod/pingpong created
```

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Viewing container output

- Let's use the `kubectl logs` command

- It takes a Pod name as argument

- Unless specified otherwise, it will only show logs of the first container in the pod

  (Good thing there's only one in ours!)

.lab[

- View the result of our `ping` command:
  ```bash
  kubectl logs pingpong
  ```

]

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Streaming logs in real time

- Just like `docker logs`, `kubectl logs` supports convenient options:

  - `-f`/`--follow` to stream logs in real time (√† la `tail -f`)

  - `--tail` to indicate how many lines you want to see (from the end)

  - `--since` to get logs only after a given timestamp

.lab[

- View the latest logs of our `ping` command:
  ```bash
  kubectl logs pingpong --tail 1 --follow
  ```

- Stop it with Ctrl-C

<!--
```wait seq=3```
```keys ^C```
-->

]

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Scaling our application

- `kubectl` gives us a simple command to scale a workload:

  `kubectl scale TYPE NAME --replicas=HOWMANY`

- Let's try it on our Pod, so that we have more Pods!

.lab[

- Try to scale the Pod:
  ```bash
  kubectl scale pod pingpong --replicas=3
  ```

]

ü§î We get the following error, what does that mean?

```
Error from server (NotFound): the server could not find the requested resource
```

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Scaling a Pod

- We cannot "scale a Pod"

  (that's not completely true; we could give it more CPU/RAM)

- If we want more Pods, we need to create more Pods

  (i.e. execute `kubectl run` multiple times)

- There must be a better way!

  (spoiler alert: yes, there is a better way!)

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

class: extra-details

## `NotFound`

- What's the meaning of that error?
  ```
  Error from server (NotFound): the server could not find the requested resource
  ```

- When we execute `kubectl scale THAT-RESOURCE --replicas=THAT-MANY`,
  <br/>
  it is like telling Kubernetes:

  *go to THAT-RESOURCE and set the scaling button to position THAT-MANY*

- Pods do not have a "scaling button"

- Try to execute the `kubectl scale pod` command with `-v6`

- We see a `PATCH` request to `/scale`: that's the "scaling button"

  (technically it's called a *subresource* of the Pod)

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Creating more pods

- We are going to create a ReplicaSet

  (= set of replicas = set of identical pods)

- In fact, we will create a Deployment, which itself will create a ReplicaSet

- Why so many layers? We'll explain that shortly, don't worry!

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Creating a Deployment running `ping`

- Let's create a Deployment instead of a single Pod

.lab[

- Create the Deployment; pay attention to the `--`:
  ```bash
  kubectl create deployment pingpong --image=alpine -- ping 127.0.0.1
  ```

]

- The `--` is used to separate:

  - "options/flags of `kubectl create`

  - command to run in the container

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## What has been created?

.lab[

<!-- ```hide kubectl wait pod --selector=app=pingpong --for condition=ready ``` -->

- Check the resources that were created:
  ```bash
  kubectl get all
  ```

]

Note: `kubectl get all` is a lie. It doesn't show everything.

(But it shows a lot of "usual suspects", i.e. commonly used resources.)

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## There's a lot going on here!

```
NAME                            READY   STATUS        RESTARTS   AGE
pod/pingpong                    1/1     Running       0          4m17s
pod/pingpong-6ccbc77f68-kmgfn   1/1     Running       0          11s

NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
service/kubernetes   ClusterIP   10.96.0.1    <none>        443/TCP   3h45

NAME                       READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/pingpong   1/1     1            1           11s

NAME                                  DESIRED   CURRENT   READY   AGE
replicaset.apps/pingpong-6ccbc77f68   1         1         1       11s
```

Our new Pod is not named `pingpong`, but `pingpong-xxxxxxxxxxx-yyyyy`.

We have a Deployment named `pingpong`, and an extra ReplicaSet, too. What's going on?

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## From Deployment to Pod

We have the following resources:

- `deployment.apps/pingpong`

  This is the Deployment that we just created.

- `replicaset.apps/pingpong-xxxxxxxxxx`

  This is a Replica Set created by this Deployment.

- `pod/pingpong-xxxxxxxxxx-yyyyy`

  This is a *pod* created by the Replica Set.

Let's explain what these things are.

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Pod

- Can have one or multiple containers

- Runs on a single node

  (Pod cannot "straddle" multiple nodes)

- Pods cannot be moved

  (e.g. in case of node outage)

- Pods cannot be scaled horizontally

  (except by manually creating more Pods)

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

class: extra-details

## Pod details

- A Pod is not a process; it's an environment for containers

  - it cannot be "restarted"

  - it cannot "crash"

- The containers in a Pod can crash

- They may or may not get restarted

  (depending on Pod's restart policy)

- If all containers exit successfully, the Pod ends in "Succeeded" phase

- If some containers fail and don't get restarted, the Pod ends in "Failed" phase

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Replica Set

- Set of identical (replicated) Pods

- Defined by a pod template + number of desired replicas

- If there are not enough Pods, the Replica Set creates more

  (e.g. in case of node outage; or simply when scaling up)

- If there are too many Pods, the Replica Set deletes some

  (e.g. if a node was disconnected and comes back; or when scaling down)

- We can scale up/down a Replica Set

  - we update the manifest of the Replica Set

  - as a consequence, the Replica Set controller creates/deletes Pods

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Deployment

- Replica Sets control *identical* Pods

- Deployments are used to roll out different Pods

  (different image, command, environment variables, ...)

- When we update a Deployment with a new Pod definition:

  - a new Replica Set is created with the new Pod definition

  - that new Replica Set is progressively scaled up

  - meanwhile, the old Replica Set(s) is(are) scaled down

- This is a *rolling update*, minimizing application downtime

- When we scale up/down a Deployment, it scales up/down its Replica Set

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Can we scale now?

- Let's try `kubectl scale` again, but on the Deployment!

.lab[

- Scale our `pingpong` deployment:
  ```bash
  kubectl scale deployment pingpong --replicas 3
  ```

- Note that we could also write it like this:
  ```bash
  kubectl scale deployment/pingpong --replicas 3
  ```

- Check that we now have multiple pods:
  ```bash
  kubectl get pods
  ```

]

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

class: extra-details

## Scaling a Replica Set

- What if we scale the Replica Set instead of the Deployment?

- The Deployment would notice it right away and scale back to the initial level

- The Replica Set makes sure that we have the right numbers of Pods

- The Deployment makes sure that the Replica Set has the right size

  (conceptually, it delegates the management of the Pods to the Replica Set)

- This might seem weird (why this extra layer?) but will soon make sense

  (when we will look at how rolling updates work!)

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Checking Deployment logs

- `kubectl logs` needs a Pod name

- But it can also work with a *type/name*

  (e.g. `deployment/pingpong`)

.lab[

- View the result of our `ping` command:
  ```bash
  kubectl logs deploy/pingpong --tail 2
  ```

]

- It shows us the logs of the first Pod of the Deployment

- We'll see later how to get the logs of *all* the Pods!

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Resilience

- The *deployment* `pingpong` watches its *replica set*

- The *replica set* ensures that the right number of *pods* are running

- What happens if pods disappear?

.lab[

- In a separate window, watch the list of pods:
  ```bash
  watch kubectl get pods
  ```

<!--
```wait Every 2.0s```
```tmux split-pane -v```
-->

- Destroy the pod currently shown by `kubectl logs`:
  ```
  kubectl delete pod pingpong-xxxxxxxxxx-yyyyy
  ```

<!--
```tmux select-pane -t 0```
```copy pingpong-[^-]*-.....```
```tmux last-pane```
```keys kubectl delete pod ```
```paste```
```key ^J```
```check```
-->

]

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## What happened?

- `kubectl delete pod` terminates the pod gracefully

  (sending it the TERM signal and waiting for it to shutdown)

- As soon as the pod is in "Terminating" state, the Replica Set replaces it

- But we can still see the output of the "Terminating" pod in `kubectl logs`

- Until 30 seconds later, when the grace period expires

- The pod is then killed, and `kubectl logs` exits

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

## Deleting a standalone Pod

- What happens if we delete a standalone Pod?
 
  (like the first `pingpong` Pod that we created)

.lab[

- Delete the Pod:
  ```bash
  kubectl delete pod pingpong
  ```

<!--
```key ^D```
```key ^C```
-->

]

- No replacement Pod gets created because there is no *controller* watching it

- That's why we will rarely use standalone Pods in practice

  (except for e.g. punctual debugging or executing a short supervised task)

???

:EN:- Running pods and deployments
:FR:- Cr√©er un pod et un d√©ploiement

.debug[[k8s/kubectl-run.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-run.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/ShippingContainerSFBay.jpg)]

---

name: toc-revisiting-kubectl-logs
class: title

 Revisiting `kubectl logs`

.nav[
[Previous part](#toc-running-our-first-containers-on-kubernetes)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-exposing-containers)
]

.debug[(automatically generated title slide)]

---
# Revisiting `kubectl logs`

- In this section, we assume that we have a Deployment with multiple Pods

  (e.g. `pingpong` that we scaled to at least 3 pods)

- We will highlights some of the limitations of `kubectl logs`

.debug[[k8s/kubectl-logs.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-logs.md)]
---

## Streaming logs of multiple pods

- By default, `kubectl logs` shows us the output of a single Pod

.lab[

- Try to check the output of the Pods related to a Deployment:
  ```bash
  kubectl logs deploy/pingpong --tail 1 --follow
  ```

<!--
```wait using pod/pingpong-```
```keys ^C```
-->

]

`kubectl logs` only shows us the logs of one of the Pods.

.debug[[k8s/kubectl-logs.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-logs.md)]
---

## Viewing logs of multiple pods

- When we specify a deployment name, only one single pod's logs are shown

- We can view the logs of multiple pods by specifying a *selector*

- If we check the pods created by the deployment, they all have the label `app=pingpong`

  (this is just a default label that gets added when using `kubectl create deployment`)

.lab[

- View the last line of log from all pods with the `app=pingpong` label:
  ```bash
  kubectl logs -l app=pingpong --tail 1
  ```

]

.debug[[k8s/kubectl-logs.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-logs.md)]
---

## Streaming logs of multiple pods

- Can we stream the logs of all our `pingpong` pods?

.lab[

- Combine `-l` and `-f` flags:
  ```bash
  kubectl logs -l app=pingpong --tail 1 -f
  ```

<!--
```wait seq=```
```key ^C```
-->

]

*Note: combining `-l` and `-f` is only possible since Kubernetes 1.14!*

*Let's try to understand why ...*

.debug[[k8s/kubectl-logs.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-logs.md)]
---

class: extra-details

## Streaming logs of many pods

- Let's see what happens if we try to stream the logs for more than 5 pods

.lab[

- Scale up our deployment:
  ```bash
  kubectl scale deployment pingpong --replicas=8
  ```

- Stream the logs:
  ```bash
  kubectl logs -l app=pingpong --tail 1 -f
  ```

<!-- ```wait error:``` -->

]

We see a message like the following one:
```
error: you are attempting to follow 8 log streams,
but maximum allowed concurency is 5,
use --max-log-requests to increase the limit
```

.debug[[k8s/kubectl-logs.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-logs.md)]
---

class: extra-details

## Why can't we stream the logs of many pods?

- `kubectl` opens one connection to the API server per pod

- For each pod, the API server opens one extra connection to the corresponding kubelet

- If there are 1000 pods in our deployment, that's 1000 inbound + 1000 outbound connections on the API server

- This could easily put a lot of stress on the API server

- Prior Kubernetes 1.14, it was decided to *not* allow multiple connections

- From Kubernetes 1.14, it is allowed, but limited to 5 connections

  (this can be changed with `--max-log-requests`)

- For more details about the rationale, see
  [PR #67573](https://github.com/kubernetes/kubernetes/pull/67573)

.debug[[k8s/kubectl-logs.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-logs.md)]
---

## Shortcomings of `kubectl logs`

- We don't see which pod sent which log line

- If pods are restarted / replaced, the log stream stops

- If new pods are added, we don't see their logs

- To stream the logs of multiple pods, we need to write a selector

- There are external tools to address these shortcomings

  (e.g.: [Stern](https://github.com/stern/stern))

.debug[[k8s/kubectl-logs.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-logs.md)]
---

class: extra-details

## `kubectl logs -l ... --tail N`

- If we run this with Kubernetes 1.12, the last command shows multiple lines

- This is a regression when `--tail` is used together with `-l`/`--selector`

- It always shows the last 10 lines of output for each container

  (instead of the number of lines specified on the command line)

- The problem was fixed in Kubernetes 1.13

*See [#70554](https://github.com/kubernetes/kubernetes/issues/70554) for details.*

???

:EN:- Viewing logs with "kubectl logs"
:FR:- Consulter les logs avec "kubectl logs"

.debug[[k8s/kubectl-logs.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectl-logs.md)]
---
## 19,000 words

They say, "a picture is worth one thousand words."

The following 19 slides show what really happens when we run:

```bash
kubectl create deployment web --image=nginx
```

.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/01.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/02.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/03.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/04.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/05.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/06.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/07.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/08.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/09.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/10.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/11.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/12.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/13.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/14.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/15.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/16.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/17.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/18.svg)
.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---
class: pic
![](images/kubectl-create-deployment-slideshow/19.svg)

.debug[[k8s/deploymentslideshow.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/deploymentslideshow.md)]
---

class: pic

.interstitial[![Image separating from the next part](https://prettypictures.container.training/containers/aerial-view-of-containers.jpg)]

---

name: toc-exposing-containers
class: title

 Exposing containers

.nav[
[Previous part](#toc-revisiting-kubectl-logs)
|
[Back to table of contents](#toc-part-4)
|
[Next part](#toc-)
]

.debug[(automatically generated title slide)]

---
# Exposing containers

- We can connect to our pods using their IP address

- Then we need to figure out a lot of things:

  - how do we look up the IP address of the pod(s)?

  - how do we connect from outside the cluster?

  - how do we load balance traffic?

  - what if a pod fails?

- Kubernetes has a resource type named *Service*

- Services address all these questions!

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## Running containers with open ports

- Since `ping` doesn't have anything to connect to, we'll have to run something else

- We are going to use `jpetazzo/color`, a tiny HTTP server written in Go

- `jpetazzo/color` listens on port 80

- It serves a page showing the pod's name

  (this will be useful when checking load balancing behavior)

- We could also use the `nginx` official image instead

  (but we wouldn't be able to tell the backends from each other)

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## Running our HTTP server

- We will create a deployment with `kubectl create deployment`

- This will create a Pod running our HTTP server

.lab[

- Create a deployment named `blue`:
  ```bash
  kubectl create deployment blue --image=jpetazzo/color
  ```

]

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## Connecting to the HTTP server

- Let's connect to the HTTP server directly

  (just to make sure everything works fine; we'll add the Service later)

.lab[

- Get the IP address of the Pod:
  ```bash
  kubectl get pods -o wide
  ```

- Send an HTTP request to the Pod:
  ```bash
  curl http://`IP-ADDRESSS`
  ```

]

You should see a response from the Pod.

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

class: extra-details

## Running with a local cluster

If you're running with a local cluster (Docker Desktop, KinD, minikube...),
you might get a connection timeout (or a message like "no route to host")
because the Pod isn't reachable directly from your local machine.

In that case, you can test the connection to the Pod by running a shell
*inside* the cluster:

```bash
kubectl run -it --rm my-test-pod --image=fedora
```

Then run `curl` in that Pod.

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## The Pod doesn't have a "stable identity"

- The IP address that we used above isn't "stable"

  (if the Pod gets deleted, the replacement Pod will have a different address)

.lab[

- Check the IP addresses of running Pods:
  ```bash
  watch kubectl get pods -o wide
  ```

- Delete the Pod:
  ```bash
  kubectl delete pod `blue-xxxxxxxx-yyyyy`
  ```

- Check that the replacement Pod has a different IP address

]

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## Services in a nutshell

- Services give us a *stable endpoint* to connect to a pod or a group of pods

- An easy way to create a service is to use `kubectl expose`

- If we have a deployment named `my-little-deploy`, we can run:

  `kubectl expose deployment my-little-deploy --port=80`

  ... and this will create a service with the same name (`my-little-deploy`)

- Services are automatically added to an internal DNS zone

  (in the example above, our code can now connect to http://my-little-deploy/)

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## Exposing our deployment

- Let's create a Service for our Deployment

.lab[

- Expose the HTTP port of our server:
  ```bash
  kubectl expose deployment blue --port=80
  ```

- Look up which IP address was allocated:
  ```bash
  kubectl get service
  ```

]

- By default, this created a `ClusterIP` service

  (we'll discuss later the different types of services)

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

class: extra-details

## Services are layer 4 constructs

- Services can have IP addresses, but they are still *layer 4*

  (i.e. a service is not just an IP address; it's an IP address + protocol + port)

- As a result: you *have to* indicate the port number for your service
    
  (with some exceptions, like `ExternalName` or headless services, covered later)

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## Testing our service

- We will now send a few HTTP requests to our Pod

.lab[

- Let's obtain the IP address that was allocated for our service, *programmatically:*
  ```bash
  CLUSTER_IP=$(kubectl get svc blue -o go-template='{{ .spec.clusterIP }}')
  ```

<!--
```hide kubectl wait deploy blue --for condition=available```
```key ^D```
```key ^C```
-->

- Send a few requests:
  ```bash
  for i in $(seq 10); do curl http://$CLUSTER_IP; done
  ```

]

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## A *stable* endpoint

- Let's see what happens when the Pod has a problem

.lab[

- Keep sending requests to the Service address:
  ```bash
  while sleep 0.3; do curl http://$CLUSTER_IP; done
  ```

- Meanwhile, delete the Pod:
  ```bash
  kubectl delete pod `blue-xxxxxxxx-yyyyy`
  ```

]

- There might be a short interruption when we delete the pod...

- ...But requests will keep flowing after that (without requiring a manual intervention)

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## Load balancing

- The Service will also act as a load balancer

  (if there are multiple Pods in the Deployment)

.lab[

- Scale up the Deployment:
  ```bash
  kubectl scale deployment blue --replicas=3
  ```

- Send a bunch of requests to the Service:
  ```bash
  for i in $(seq 20); do curl http://$CLUSTER_IP; done
  ```

]

- Our requests are load balanced across the Pods!

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## DNS integration

- Kubernetes provides an internal DNS resolver

- The resolver maps service names to their internal addresses

- By default, this only works *inside Pods* (not from the nodes themselves)

.lab[

- Get a shell in a Pod:
  ```bash
  kubectl run --rm -it --image=fedora test-dns-integration
  ```

- Try to resolve the `blue` Service from the Pod:
  ```bash
  curl blue
  ```

]

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

class: extra-details

## Under the hood...

- Check the content of `/etc/resolv.conf` inside a Pod

- It will have `nameserver X.X.X.X` (e.g. 10.96.0.10)

- Now check `kubectl get service kube-dns --namespace=kube-system`

- ...It's the same address! üòâ

- The FQDN of a service is actually:

  `<service-name>.<namespace>.svc.<cluster-domain>`

- `<cluster-domain>` defaults to `cluster.local`

- And the `search` includes `<namespace>.svc.<cluster-domain>`

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]
---

## Advantages of services

- We don't need to look up the IP address of the pod(s)

  (we resolve the IP address of the service using DNS)

- There are multiple service types; some of them allow external traffic

  (e.g. `LoadBalancer` and `NodePort`)

- Services provide load balancing

  (for both internal and external traffic)

- Service addresses are independent from pods' addresses

  (when a pod fails, the service seamlessly sends traffic to its replacement)

???

:EN:- Accessing pods through services
:EN:- Service discovery and load balancing

:FR:- Exposer un service
:FR:- Le DNS interne de Kubernetes et la *service discovery*

.debug[[k8s/kubectlexpose.md](https://github.com/GuillaumeMorini/orchestration-workshop/tree/efrei/slides/k8s/kubectlexpose.md)]</textarea>
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        ratio: '16:9',
        highlightSpans: true,
        slideNumberFormat: '%current%/%total%',
        excludedClasses: ["self-paced"]
      });
    </script>
    <script type="module">
      import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: false });
        slideshow.on('afterShowSlide', function (slide) {
          mermaid.run({
            nodes: document.querySelectorAll('div.remark-visible .mermaid'),
          });
        });
        // Reminder, if you want to tinker with mermaid,
        // you need to export it, for instance like this:
        // window.mermaid = mermaid;
    </script>

    <!-- 
    These two scripts will be available only when loading the
    content using the pub/sub server. Otherwise, they'll just
    404 and that's OK.
    -->
    <script src="/socket.io/socket.io.js">
    </script>
    <script src="/remote.js">
    </script>

  </body>
</html>
